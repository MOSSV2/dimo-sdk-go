// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package file

import (
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// IFileFileInfo is an auto generated low-level Go binding around an user-defined struct.
type IFileFileInfo struct {
	Name   string
	Owner  common.Address
	Price  *big.Int
	Start  uint64
	Expire uint64
	Count  uint64
}

// IFilePieceInfo is an auto generated low-level Go binding around an user-defined struct.
type IFilePieceInfo struct {
	Name    []byte
	Replica []uint64
}

// IFileReplicaInfo is an auto generated low-level Go binding around an user-defined struct.
type IFileReplicaInfo struct {
	Name     []byte
	File     uint64
	StoredOn common.Address
}

// IFileStoreInfo is an auto generated low-level Go binding around an user-defined struct.
type IFileStoreInfo struct {
	Epoch  uint64
	Active uint64
	Count  uint64
	Salary *big.Int
}

// IFileStoreStat is an auto generated low-level Go binding around an user-defined struct.
type IFileStoreStat struct {
	Count  uint64
	Active uint64
	Reward *big.Int
}

// ContextABI is the input ABI used to generate the binding from.
const ContextABI = "[]"

// Context is an auto generated Go binding around an Ethereum contract.
type Context struct {
	ContextCaller     // Read-only binding to the contract
	ContextTransactor // Write-only binding to the contract
	ContextFilterer   // Log filterer for contract events
}

// ContextCaller is an auto generated read-only Go binding around an Ethereum contract.
type ContextCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ContextTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ContextFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ContextSession struct {
	Contract     *Context          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ContextCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ContextCallerSession struct {
	Contract *ContextCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// ContextTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ContextTransactorSession struct {
	Contract     *ContextTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// ContextRaw is an auto generated low-level Go binding around an Ethereum contract.
type ContextRaw struct {
	Contract *Context // Generic contract binding to access the raw methods on
}

// ContextCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ContextCallerRaw struct {
	Contract *ContextCaller // Generic read-only contract binding to access the raw methods on
}

// ContextTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ContextTransactorRaw struct {
	Contract *ContextTransactor // Generic write-only contract binding to access the raw methods on
}

// NewContext creates a new instance of Context, bound to a specific deployed contract.
func NewContext(address common.Address, backend bind.ContractBackend) (*Context, error) {
	contract, err := bindContext(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Context{ContextCaller: ContextCaller{contract: contract}, ContextTransactor: ContextTransactor{contract: contract}, ContextFilterer: ContextFilterer{contract: contract}}, nil
}

// NewContextCaller creates a new read-only instance of Context, bound to a specific deployed contract.
func NewContextCaller(address common.Address, caller bind.ContractCaller) (*ContextCaller, error) {
	contract, err := bindContext(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ContextCaller{contract: contract}, nil
}

// NewContextTransactor creates a new write-only instance of Context, bound to a specific deployed contract.
func NewContextTransactor(address common.Address, transactor bind.ContractTransactor) (*ContextTransactor, error) {
	contract, err := bindContext(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ContextTransactor{contract: contract}, nil
}

// NewContextFilterer creates a new log filterer instance of Context, bound to a specific deployed contract.
func NewContextFilterer(address common.Address, filterer bind.ContractFilterer) (*ContextFilterer, error) {
	contract, err := bindContext(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ContextFilterer{contract: contract}, nil
}

// bindContext binds a generic wrapper to an already deployed contract.
func bindContext(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ContextABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Context *ContextRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Context.Contract.ContextCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Context *ContextRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Context.Contract.ContextTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Context *ContextRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Context.Contract.ContextTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Context *ContextCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Context.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Context *ContextTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Context.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Context *ContextTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Context.Contract.contract.Transact(opts, method, params...)
}

// FileABI is the input ABI used to generate the binding from.
const FileABI = "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_b\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_fi\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_fn\",\"type\":\"string\"}],\"name\":\"AddFile\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_fi\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_pi\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_piece\",\"type\":\"bytes\"}],\"name\":\"AddPiece\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_fi\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_pi\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_ri\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_rn\",\"type\":\"bytes\"}],\"name\":\"AddReplica\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_e\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_m\",\"type\":\"uint256\"}],\"name\":\"Settle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_m\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_fn\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_p\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_e\",\"type\":\"uint64\"}],\"name\":\"addFile\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_fi\",\"type\":\"uint64\"},{\"internalType\":\"bytes[]\",\"name\":\"_piece\",\"type\":\"bytes[]\"}],\"name\":\"addPiece\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_fi\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_pi\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_rn\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_sign\",\"type\":\"bytes\"}],\"name\":\"addReplica\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bank\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"current\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delay\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_fi\",\"type\":\"uint64\"}],\"name\":\"getFile\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"expire\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"count\",\"type\":\"uint64\"}],\"internalType\":\"structIFile.FileInfo\",\"name\":\"_fb\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_fn\",\"type\":\"string\"}],\"name\":\"getFileIndex\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_fi\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_pi\",\"type\":\"uint64\"}],\"name\":\"getPiece\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"uint64[]\",\"name\":\"replica\",\"type\":\"uint64[]\"}],\"internalType\":\"structIFile.PieceInfo\",\"name\":\"_pinfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_fi\",\"type\":\"uint64\"}],\"name\":\"getPrepay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_r\",\"type\":\"bytes\"}],\"name\":\"getRExpire\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_r\",\"type\":\"uint64\"}],\"name\":\"getReplica\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"file\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"storedOn\",\"type\":\"address\"}],\"internalType\":\"structIFile.ReplicaInfo\",\"name\":\"_ri\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_rn\",\"type\":\"bytes\"}],\"name\":\"getReplicaIndex\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_ri\",\"type\":\"uint64\"}],\"name\":\"getSReplica\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"_r\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_e\",\"type\":\"uint64\"}],\"name\":\"getSStat\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"count\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"active\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"internalType\":\"structIFile.StoreStat\",\"name\":\"_si\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"getStore\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"epoch\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"active\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"count\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"salary\",\"type\":\"uint256\"}],\"internalType\":\"structIFile.StoreInfo\",\"name\":\"_si\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_e\",\"type\":\"uint64\"}],\"name\":\"getStoreAt\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_fi\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"isAgent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxStore\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStore\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_fi\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"_m\",\"type\":\"uint256\"}],\"name\":\"prePay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_fi\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_p\",\"type\":\"address\"}],\"name\":\"setAgent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_ep\",\"type\":\"uint64\"}],\"name\":\"settle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_m\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_fi\",\"type\":\"uint64\"}],\"name\":\"withdrawPrepay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// FileFuncSigs maps the 4-byte function signature to its string representation.
var FileFuncSigs = map[string]string{
	"c1c2e09c": "addFile(string,uint256,uint64)",
	"84826517": "addPiece(uint64,bytes[])",
	"91601d9e": "addReplica(uint64,uint64,bytes,bytes)",
	"70a08231": "balanceOf(address)",
	"76cdb03b": "bank()",
	"9fa6a6e3": "current()",
	"6a42b8f8": "delay()",
	"bb2d4d49": "getFile(uint64)",
	"3a832ec8": "getFileIndex(string)",
	"dcc8922e": "getPiece(uint64,uint64)",
	"6bbd5f87": "getPrepay(uint64)",
	"accbe33b": "getRExpire(bytes)",
	"9108544c": "getReplica(uint64)",
	"386e6da6": "getReplicaIndex(bytes)",
	"6f3e37b1": "getSReplica(address,uint64)",
	"c3aa3804": "getSStat(address,uint64)",
	"4b4ffccd": "getStore(address)",
	"6150ad81": "getStoreAt(address,uint64)",
	"e5107912": "isAgent(uint64,address)",
	"fca5be7a": "maxStore()",
	"88795125": "minStore()",
	"8da5cb5b": "owner()",
	"6c050b38": "prePay(uint64,uint256)",
	"715018a6": "renounceOwnership()",
	"228cb733": "reward()",
	"134cd2bd": "setAgent(uint64,address)",
	"4b9ba446": "settle(uint64)",
	"f2fde38b": "transferOwnership(address)",
	"2e1a7d4d": "withdraw(uint256)",
	"4abeafd8": "withdrawPrepay(uint64)",
}

// FileBin is the compiled bytecode used for deploying new contracts.
var FileBin = "0x6080604052600280546001600160c01b031916710bb8000000000000012c000000000000000a1790553480156200003557600080fd5b50604051620033f0380380620033f08339810160408190526200005891620000d9565b620000633362000089565b600180546001600160a01b0319166001600160a01b03929092169190911790556200010b565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600060208284031215620000ec57600080fd5b81516001600160a01b03811681146200010457600080fd5b9392505050565b6132d5806200011b6000396000f3fe608060405234801561001057600080fd5b50600436106101da5760003560e01c806376cdb03b11610104578063accbe33b116100a2578063dcc8922e11610071578063dcc8922e1461061c578063e51079121461063c578063f2fde38b14610690578063fca5be7a146106a357600080fd5b8063accbe33b14610522578063bb2d4d4914610535578063c1c2e09c14610555578063c3aa38041461056857600080fd5b80638da5cb5b116100de5780638da5cb5b146104c45780639108544c146104d557806391601d9e146104f55780639fa6a6e31461050857600080fd5b806376cdb03b1461046c578063848265171461049757806388795125146104aa57600080fd5b80634b9ba4461161017c5780636c050b381161014b5780636c050b38146104085780636f3e37b11461041b57806370a082311461043b578063715018a61461046457600080fd5b80634b9ba446146103495780636150ad811461035c5780636a42b8f8146103cc5780636bbd5f87146103df57600080fd5b8063386e6da6116101b8578063386e6da6146102235780633a832ec81461024e5780634abeafd8146102615780634b4ffccd1461027457600080fd5b8063134cd2bd146101df578063228cb733146101f45780632e1a7d4d14610210575b600080fd5b6101f26101ed36600461295d565b6106bd565b005b6101fd60035481565b6040519081526020015b60405180910390f35b6101f261021e366004612996565b61077c565b610236610231366004612a64565b610872565b6040516001600160401b039091168152602001610207565b61023661025c366004612a64565b6108af565b6101f261026f366004612aa0565b6108c3565b610309610282366004612ac4565b60408051608081018252600080825260208201819052918101829052606081019190915250604080516080810182526001600160a01b039092166000818152600b602081815284832080546001600160401b038082168952600160401b82048116848a0152600160801b909104169587019590955292909152905260010154606082015290565b6040805182516001600160401b03908116825260208085015182169083015283830151169181019190915260609182015191810191909152608001610207565b6101f2610357366004612aa0565b610abc565b6103ac61036a366004612ae1565b6001600160a01b03919091166000908152600d602090815260408083206001600160401b03948516845290915290205480821692600160401b90910490911690565b604080516001600160401b03938416815292909116602083015201610207565b600254610236906001600160401b031681565b6101fd6103ed366004612aa0565b6001600160401b031660009081526008602052604090205490565b6101f2610416366004612b0f565b610c3e565b61042e610429366004612ae1565b610cd3565b6040516102079190612b8b565b6101fd610449366004612ac4565b6001600160a01b03166000908152600e602052604090205490565b6101f2610dbf565b60015461047f906001600160a01b031681565b6040516001600160a01b039091168152602001610207565b6101f26104a5366004612b9e565b610dd3565b60025461023690600160401b90046001600160401b031681565b6000546001600160a01b031661047f565b6104e86104e3366004612aa0565b611058565b6040516102079190612c75565b6101f2610503366004612cc5565b6111d2565b60015461023690600160a01b90046001600160401b031681565b610236610530366004612a64565b611922565b610548610543366004612aa0565b6119d9565b6040516102079190612d4d565b6101f2610563366004612dc0565b611bfd565b6105ec610576366004612ae1565b604080516060808201835260008083526020808401829052928401819052835191820184526001600160a01b03959095168552600d82528285206001600160401b0394851680875281845284872080548088168552600160401b9004909616838501529095529390526001909101549082015290565b6040805182516001600160401b039081168252602080850151909116908201529181015190820152606001610207565b61062f61062a366004612e1a565b611f0e565b6040516102079190612e38565b61068061064a36600461295d565b6001600160401b03821660009081526007602090815260408083206001600160a01b038516845290915290205460ff1692915050565b6040519015158152602001610207565b6101f261069e366004612ac4565b612085565b60025461023690600160801b90046001600160401b031681565b336001600160a01b03166004836001600160401b0316815481106106e3576106e3612ea9565b60009182526020909120600160049092020101546001600160a01b0316146107425760405162461bcd60e51b815260206004820152600d60248201526c34b73b30b634b21037bbb732b960991b60448201526064015b60405180910390fd5b6001600160401b0390911660009081526007602090815260408083206001600160a01b03909416835292905220805460ff19166001179055565b6107846120fe565b336000908152600b6020526040902054600160801b90046001600160401b0316156107b2576107b23361237a565b336000908152600e6020526040812080548392906107d1908490612ed5565b9091555050600154604051630ed1218b60e31b8152336004820152602481018390526001600160a01b03909116906376890c5890604401600060405180830381600087803b15801561082257600080fd5b505af1158015610836573d6000803e3d6000fd5b50506040518381523392507f884edad9ce6fa2440d8a54cc123490eb96d2768479d49ff9c7366125a9424364915060200160405180910390a250565b60006001600a836040516108869190612f04565b908152604051908190036020019020546108a991906001600160401b0316612f20565b92915050565b600060016005836040516108869190612f04565b6004816001600160401b0316815481106108df576108df612ea9565b60009182526020909120600490910201600101546001600160a01b031633146109345760405162461bcd60e51b81526020600482015260076024820152661a5b9d985b1a5960ca1b6044820152606401610739565b61093c6120fe565b600154600254600480546001600160401b03600160a01b90940484169392831692851690811061096e5761096e612ea9565b600091825260209091206003600490920201015461099591906001600160401b0316612f47565b6001600160401b031611156109d45760405162461bcd60e51b81526020600482015260056024820152646561726c7960d81b6044820152606401610739565b6001546001600160401b03821660009081526008602052604090819020549051630ed1218b60e31b815233600482015260248101919091526001600160a01b03909116906376890c5890604401600060405180830381600087803b158015610a3b57600080fd5b505af1158015610a4f573d6000803e3d6000fd5b505050506001600160401b03811660009081526008602090815260409182902054915191825233917f884edad9ce6fa2440d8a54cc123490eb96d2768479d49ff9c7366125a9424364910160405180910390a26001600160401b0316600090815260086020526040812055565b610ac46120fe565b610acd3361237a565b610ad63361246d565b600154600090610af890600390600160a01b90046001600160401b0316612f20565b9050806001600160401b0316826001600160401b03161115610b445760405162461bcd60e51b81526020600482015260056024820152646561726c7960d81b6044820152606401610739565b336000908152600d602090815260408083206001600160401b0386168452909152902060010154610b76906002612f67565b336000908152600e602052604081208054909190610b95908490612f7e565b9091555050336000818152600d602090815260408083206001600160401b03871684529091529020600101547f22b9b452d488700bdfeab2aa62972ac1fce3160583db89ab4c799708bf5a2c6c908490610bf0906002612f67565b604080516001600160401b03909316835260208301919091520160405180910390a250336000908152600d602090815260408083206001600160401b03909416835292905290812060010155565b60015460405163e888891560e01b8152336004820152602481018390526001600160a01b039091169063e888891590604401600060405180830381600087803b158015610c8a57600080fd5b505af1158015610c9e573d6000803e3d6000fd5b505050506001600160401b03821660009081526008602052604081208054839290610cca908490612f7e565b90915550505050565b6001600160a01b0382166000908152600c602090815260408083206001600160401b03948516845290915290205460098054919092169160609183908110610d1d57610d1d612ea9565b90600052602060002090600202016000018054610d3990612f91565b80601f0160208091040260200160405190810160405280929190818152602001828054610d6590612f91565b8015610db25780601f10610d8757610100808354040283529160200191610db2565b820191906000526020600020905b815481529060010190602001808311610d9557829003601f168201915b5050505050905092915050565b610dc7612682565b610dd160006126dc565b565b610ddb6120fe565b336001600160a01b03166004836001600160401b031681548110610e0157610e01612ea9565b60009182526020909120600160049092020101546001600160a01b031614610e5b5760405162461bcd60e51b815260206004820152600d60248201526c34b73b30b634b21037bbb732b960991b6044820152606401610739565b600154600480546001600160401b03600160a01b9093048316928516908110610e8657610e86612ea9565b6000918252602090912060036004909202010154610eae906001600160401b03166001612f47565b6001600160401b03161015610ef05760405162461bcd60e51b8152602060048201526008602482015267746f6f206c61746560c01b6044820152606401610739565b60006004836001600160401b031681548110610f0e57610f0e612ea9565b600091825260208220600360049092020101546001600160401b03600160801b9091041691505b825181101561100057828181518110610f5057610f50612ea9565b6020908102919091018101516001600160401b03808716600090815260068452604080822092871682529190935290912090610f8c9082613016565b507fb121db726a172f87e0af2ba7bf7351c89c3d578b2b329f421b823e7f159f453a8483858481518110610fc257610fc2612ea9565b6020026020010151604051610fd9939291906130d5565b60405180910390a1610fec600183612f47565b915080610ff88161310a565b915050610f35565b50806004846001600160401b03168154811061101e5761101e612ea9565b906000526020600020906004020160030160106101000a8154816001600160401b0302191690836001600160401b03160217905550505050565b604080516060808201835281526000602082018190529181019190915260405180606001604052806009846001600160401b03168154811061109c5761109c612ea9565b906000526020600020906002020160000180546110b890612f91565b80601f01602080910402602001604051908101604052809291908181526020018280546110e490612f91565b80156111315780601f1061110657610100808354040283529160200191611131565b820191906000526020600020905b81548152906001019060200180831161111457829003601f168201915b505050505081526020016009846001600160401b03168154811061115757611157612ea9565b906000526020600020906002020160010160009054906101000a90046001600160401b03166001600160401b031681526020016009846001600160401b0316815481106111a6576111a6612ea9565b6000918252602090912060029091020160010154600160401b90046001600160a01b0316905292915050565b6111da6120fe565b600154600254600480546001600160401b03600160a01b90940484169392831692881690811061120c5761120c612ea9565b600091825260209091206003600490920201015461123391906001600160401b0316612f47565b6001600160401b0316116112745760405162461bcd60e51b8152602060048201526008602482015267746f6f206c61746560c01b6044820152606401610739565b826001600160401b03166004856001600160401b03168154811061129a5761129a612ea9565b6000918252602090912060049091020160030154600160801b90046001600160401b0316116112fb5760405162461bcd60e51b815260206004820152600d60248201526c696e76616c696420706965636560981b6044820152606401610739565b6000600160149054906101000a90046001600160401b03166004866001600160401b03168154811061132f5761132f612ea9565b906000526020600020906004020160030160089054906101000a90046001600160401b031661135e9190612f20565b6001600160401b03166004866001600160401b03168154811061138357611383612ea9565b90600052602060002090600402016002015461139f9190612f67565b9050336001600160a01b03166004866001600160401b0316815481106113c7576113c7612ea9565b60009182526020909120600160049092020101546001600160a01b0316146114e7576001600160401b038516600090815260076020908152604080832033845290915290205460ff16151560011461144d5760405162461bcd60e51b8152602060048201526009602482015268696e76616c6964206360b81b6044820152606401610739565b6004856001600160401b03168154811061146957611469612ea9565b906000526020600020906004020160020154816114869190612f7e565b90506004856001600160401b0316815481106114a4576114a4612ea9565b90600052602060002090600402016002015460026114c29190612f67565b336000908152600e6020526040812080549091906114e1908490612f7e565b90915550505b6001600160401b03851660009081526008602052604090205481101561153a576001600160401b0385166000908152600860205260408120805483929061152f908490612ed5565b909155506116189050565b6001600160401b03851660009081526008602052604090205461155d9082612ed5565b6001600160401b038616600081815260086020526040812055600154600480549394506001600160a01b039091169263e8888915929081106115a1576115a1612ea9565b600091825260209091206004918202016001015460405160e084901b6001600160e01b03191681526001600160a01b039091169181019190915260248101849052604401600060405180830381600087803b1580156115ff57600080fd5b505af1158015611613573d6000803e3d6000fd5b505050505b806003600082825461162a9190612f7e565b90915550506001600160401b038086166000908152600660209081526040808320938816835292815282822092519192611668923092889101613123565b60408051601f198184030181529082905280516020909101206319045a2560e01b8252915060009073__$7051fc88d7d3ee2986350c12aa434dc4ca$__906319045a25906116bc90859088906004016131c6565b602060405180830381865af41580156116d9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116fd91906131df565b90506117088161237a565b60098054604080516060810182526001600160401b038b1660208201528881526001600160a01b03851691810191909152600182018355600092909252815190919081907f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7af600285020190819061177f9082613016565b506020820151600191820180546040909401516001600160a01b0316600160401b026001600160e01b03199094166001600160401b0390921691909117929092179091556117ce908390612f47565b600a886040516117de9190612f04565b9081526040805160209281900383019020805467ffffffffffffffff19166001600160401b039485161790558b83166000818152600684528281208d8616825284529182206001908101805491820181558352929091206004808404909101805460039094166008026101000a80860219909416948716939093029390931790915581546118d09286928692811061187857611878612ea9565b906000526020600020906004020160030160089054906101000a90046001600160401b031660048d6001600160401b0316815481106118b9576118b9612ea9565b90600052602060002090600402016002015461272c565b826001600160a01b03167f9ad879f74989d3436fd7b3ab155a0d4af6ae45b6f98d91513e1398e0bc3afa158a8a858b60405161190f94939291906131fc565b60405180910390a2505050505050505050565b6000806001600a846040516119379190612f04565b9081526040519081900360200190205461195a91906001600160401b0316612f20565b90506009816001600160401b03168154811061197857611978612ea9565b6000918252602090912060016002909202010154600480546001600160401b03909216925090829081106119ae576119ae612ea9565b6000918252602090912060049091020160030154600160401b90046001600160401b03169392505050565b6040805160c081018252606080825260006020830181905292820183905281018290526080810182905260a08101919091526004826001600160401b031681548110611a2757611a27612ea9565b90600052602060002090600402016000018054611a4390612f91565b80601f0160208091040260200160405190810160405280929190818152602001828054611a6f90612f91565b8015611abc5780601f10611a9157610100808354040283529160200191611abc565b820191906000526020600020905b815481529060010190602001808311611a9f57829003601f168201915b5050509183525050600480546001600160401b038416908110611ae157611ae1612ea9565b6000918252602091829020600491820201600101546001600160a01b03169183019190915280546001600160401b038416908110611b2157611b21612ea9565b9060005260206000209060040201600201548160400181815250506004826001600160401b031681548110611b5857611b58612ea9565b60009182526020909120600491820201600301546001600160401b0390811660608401528154908416908110611b9057611b90612ea9565b6000918252602090912060049182020160030154600160401b90046001600160401b0390811660808401528154908416908110611bcf57611bcf612ea9565b6000918252602090912060049091020160030154600160801b90046001600160401b031660a0820152919050565b611c056120fe565b600583604051611c159190612f04565b908152604051908190036020019020546001600160401b031615611c635760405162461bcd60e51b8152602060048201526005602482015264195e1a5cdd60da1b6044820152606401610739565b600254600154611c8d916001600160401b03600160401b909104811691600160a01b900416612f47565b6001600160401b0316816001600160401b03161015611cdf5760405162461bcd60e51b815260206004820152600e60248201526d39b437b93a10323ab930ba34b7b760911b6044820152606401610739565b600254600154611d09916001600160401b03600160801b909104811691600160a01b900416612f47565b6001600160401b0316816001600160401b031610611d5b5760405162461bcd60e51b815260206004820152600f60248201526e32bc31b2b2b210323ab930ba34b7b760891b6044820152606401610739565b6040805160c081018252600060a08201819052858252336020830152918101849052600180546001600160401b03600160a01b90910481166060840152841660808301526004805491820181559283905281519192839291027f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b01908190611de39082613016565b5060208201516001820180546001600160a01b039092166001600160a01b03199092169190911790556040808301516002830155606083015160039092018054608085015160a0909501516001600160401b03908116600160801b0267ffffffffffffffff60801b19968216600160401b026fffffffffffffffffffffffffffffffff1990931691909516171793909316919091179091556004549051600590611e8e908790612f04565b90815260405190819003602001902080546001600160401b039290921667ffffffffffffffff1990921691909117905560045433907f97fbaabf7920b8891ffb1c0610284ba7fc4b47b0f7ba084b2e634d496da89d2990611ef190600190612f20565b86604051611f0092919061323a565b60405180910390a250505050565b60408051808201909152606080825260208201526001600160401b0380841660009081526006602090815260408083209386168352929052208054611f5290612f91565b80601f0160208091040260200160405190810160405280929190818152602001828054611f7e90612f91565b8015611fcb5780601f10611fa057610100808354040283529160200191611fcb565b820191906000526020600020905b815481529060010190602001808311611fae57829003601f168201915b50505091835250506001600160401b0380841660009081526006602090815260408083209386168352928152908290206001018054835181840281018401909452808452909183018282801561207257602002820191906000526020600020906000905b82829054906101000a90046001600160401b03166001600160401b03168152602001906008019060208260070104928301926001038202915080841161202f5790505b5050505050816020018190525092915050565b61208d612682565b6001600160a01b0381166120f25760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610739565b6120fb816126dc565b50565b60015460405163349f642f60e11b81526020600482015260056024820152640cae0dec6d60db1b60448201526000916001600160a01b03169063693ec85e906064016020604051808303816000875af115801561215f573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061218391906131df565b9050806001600160a01b031663919840ad6040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156121c057600080fd5b505af11580156121d4573d6000803e3d6000fd5b505050506000816001600160a01b0316639fa6a6e36040518163ffffffff1660e01b81526004016020604051808303816000875af115801561221a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061223e919061325c565b6001549091506001600160401b03600160a01b909104811690821611156123765760015460405163349f642f60e11b815260206004820152600760248201526618dbdb9d1c9bdb60ca1b60448201526001600160a01b039091169063693ec85e906064016020604051808303816000875af11580156122c1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122e591906131df565b6003546040516340c10f1960e01b815230600482015260248101919091526001600160a01b0391909116906340c10f1990604401600060405180830381600087803b15801561233357600080fd5b505af1158015612347573d6000803e3d6000fd5b5050600060035550506001805467ffffffffffffffff60a01b1916600160a01b6001600160401b038416021790555b5050565b60015460405163349f642f60e11b81526000916001600160a01b03169063693ec85e906123c2906004016020808252600490820152636e6f646560e01b604082015260600190565b6020604051808303816000875af11580156123e1573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061240591906131df565b6040516361e728b160e01b81526001600160a01b03848116600483015260016024830152919250908216906361e728b19060440160006040518083038186803b15801561245157600080fd5b505afa158015612465573d6000803e3d6000fd5b505050505050565b6001600160a01b0381166000908152600b60205260408120546001600160401b031690036124d7576001546001600160a01b0382166000908152600b602052604090208054600160a01b9092046001600160401b031667ffffffffffffffff199092169190911790555b6001600160a01b0381166000908152600b60205260409020546001600160401b03165b6001546001600160401b03600160a01b9091048116908216101561263c576001600160a01b0382166000818152600d602090815260408083206001600160401b03861684528252808320600190810154948452600b90925290912001546125619190612ed5565b6001600160a01b0383166000818152600d602090815260408083206001600160401b0387811685529083528184206001810196909655938352600b90915290208054835467ffffffffffffffff1916600160801b90910483161792839055546125d892600160401b90819004831692910416612f20565b6001600160a01b0383166000908152600d602090815260408083206001600160401b038681168552925290912080546fffffffffffffffff00000000000000001916600160401b93909216929092021790558061263481613279565b9150506124fa565b506001546001600160a01b039091166000908152600b60205260409020805467ffffffffffffffff19166001600160401b03600160a01b90930492909216919091179055565b6000546001600160a01b03163314610dd15760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610739565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6127358461246d565b6001600160a01b0384166000818152600c60209081526040808320600b8084528285208054600160801b908190046001600160401b039081168852938652938620805467ffffffffffffffff19168b851617905595909452929091528254600193926010926127a992869291900416612f47565b92506101000a8154816001600160401b0302191690836001600160401b0316021790555080600b6000866001600160a01b03166001600160a01b0316815260200190815260200160002060010160008282546128059190612f7e565b90915550506001600160a01b0384166000908152600b60205260409020805460019190600890612846908490600160401b90046001600160401b0316612f47565b92506101000a8154816001600160401b0302191690836001600160401b0316021790555080600d6000866001600160a01b03166001600160a01b031681526020019081526020016000206000846001600160401b03166001600160401b0316815260200190815260200160002060010160008282546128c59190612f7e565b90915550506001600160a01b0384166000908152600d602090815260408083206001600160401b038087168552925282208054600193919261290991859116612f47565b92506101000a8154816001600160401b0302191690836001600160401b0316021790555050505050565b6001600160401b03811681146120fb57600080fd5b6001600160a01b03811681146120fb57600080fd5b6000806040838503121561297057600080fd5b823561297b81612933565b9150602083013561298b81612948565b809150509250929050565b6000602082840312156129a857600080fd5b5035919050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b03811182821017156129ed576129ed6129af565b604052919050565b600082601f830112612a0657600080fd5b81356001600160401b03811115612a1f57612a1f6129af565b612a32601f8201601f19166020016129c5565b818152846020838601011115612a4757600080fd5b816020850160208301376000918101602001919091529392505050565b600060208284031215612a7657600080fd5b81356001600160401b03811115612a8c57600080fd5b612a98848285016129f5565b949350505050565b600060208284031215612ab257600080fd5b8135612abd81612933565b9392505050565b600060208284031215612ad657600080fd5b8135612abd81612948565b60008060408385031215612af457600080fd5b8235612aff81612948565b9150602083013561298b81612933565b60008060408385031215612b2257600080fd5b8235612b2d81612933565b946020939093013593505050565b60005b83811015612b56578181015183820152602001612b3e565b50506000910152565b60008151808452612b77816020860160208601612b3b565b601f01601f19169290920160200192915050565b602081526000612abd6020830184612b5f565b60008060408385031215612bb157600080fd5b8235612bbc81612933565b91506020838101356001600160401b0380821115612bd957600080fd5b818601915086601f830112612bed57600080fd5b813581811115612bff57612bff6129af565b8060051b612c0e8582016129c5565b918252838101850191858101908a841115612c2857600080fd5b86860192505b83831015612c6457823585811115612c465760008081fd5b612c548c89838a01016129f5565b8352509186019190860190612c2e565b809750505050505050509250929050565b602081526000825160606020840152612c916080840182612b5f565b60208501516001600160401b0316604085810191909152909401516001600160a01b03166060909301929092525090919050565b60008060008060808587031215612cdb57600080fd5b8435612ce681612933565b93506020850135612cf681612933565b925060408501356001600160401b0380821115612d1257600080fd5b612d1e888389016129f5565b93506060870135915080821115612d3457600080fd5b50612d41878288016129f5565b91505092959194509250565b602081526000825160c06020840152612d6960e0840182612b5f565b905060018060a01b0360208501511660408401526040840151606084015260608401516001600160401b0380821660808601528060808701511660a08601528060a08701511660c086015250508091505092915050565b600080600060608486031215612dd557600080fd5b83356001600160401b03811115612deb57600080fd5b612df7868287016129f5565b935050602084013591506040840135612e0f81612933565b809150509250925092565b60008060408385031215612e2d57600080fd5b8235612aff81612933565b600060208083528351604082850152612e546060850182612b5f565b85830151858203601f19016040870152805180835290840192506000918401905b80831015612e9e5783516001600160401b03168252928401926001929092019190840190612e75565b509695505050505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b818103818111156108a9576108a9612ebf565b60008151612efa818560208601612b3b565b9290920192915050565b60008251612f16818460208701612b3b565b9190910192915050565b6001600160401b03828116828216039080821115612f4057612f40612ebf565b5092915050565b6001600160401b03818116838216019080821115612f4057612f40612ebf565b80820281158282048414176108a9576108a9612ebf565b808201808211156108a9576108a9612ebf565b600181811c90821680612fa557607f821691505b602082108103612fc557634e487b7160e01b600052602260045260246000fd5b50919050565b601f82111561301157600081815260208120601f850160051c81016020861015612ff25750805b601f850160051c820191505b8181101561246557828155600101612ffe565b505050565b81516001600160401b0381111561302f5761302f6129af565b6130438161303d8454612f91565b84612fcb565b602080601f83116001811461307857600084156130605750858301515b600019600386901b1c1916600185901b178555612465565b600085815260208120601f198616915b828110156130a757888601518255948401946001909101908401613088565b50858210156130c55787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b60006001600160401b038086168352808516602084015250606060408301526131016060830184612b5f565b95945050505050565b60006001820161311c5761311c612ebf565b5060010190565b6bffffffffffffffffffffffff198460601b168152600060146000855461314981612f91565b60018281168015613161576001811461317a576131ad565b60ff1984168887015282151583028801860194506131ad565b8960005260208060002060005b858110156131a25781548b82018a0152908401908201613187565b505050858389010194505b505050506131bb8186612ee8565b979650505050505050565b828152604060208201526000612a986040830184612b5f565b6000602082840312156131f157600080fd5b8151612abd81612948565b60006001600160401b0380871683528086166020840152808516604084015250608060608301526132306080830184612b5f565b9695505050505050565b6001600160401b0383168152604060208201526000612a986040830184612b5f565b60006020828403121561326e57600080fd5b8151612abd81612933565b60006001600160401b0380831681810361329557613295612ebf565b600101939250505056fea2646970667358221220d00ce83ac2af8a73d38d9ca79794a78ebe574ab88efeadcf07d7eba0bec0c2c564736f6c63430008130033"

// DeployFile deploys a new Ethereum contract, binding an instance of File to it.
func DeployFile(auth *bind.TransactOpts, backend bind.ContractBackend, _b common.Address) (common.Address, *types.Transaction, *File, error) {
	parsed, err := abi.JSON(strings.NewReader(FileABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	recoverAddr, _, _, _ := DeployRecover(auth, backend)
	FileBin = strings.Replace(FileBin, "__$7051fc88d7d3ee2986350c12aa434dc4ca$__", recoverAddr.String()[2:], -1)

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(FileBin), backend, _b)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &File{FileCaller: FileCaller{contract: contract}, FileTransactor: FileTransactor{contract: contract}, FileFilterer: FileFilterer{contract: contract}}, nil
}

// File is an auto generated Go binding around an Ethereum contract.
type File struct {
	FileCaller     // Read-only binding to the contract
	FileTransactor // Write-only binding to the contract
	FileFilterer   // Log filterer for contract events
}

// FileCaller is an auto generated read-only Go binding around an Ethereum contract.
type FileCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FileTransactor is an auto generated write-only Go binding around an Ethereum contract.
type FileTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FileFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type FileFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FileSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type FileSession struct {
	Contract     *File             // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// FileCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type FileCallerSession struct {
	Contract *FileCaller   // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// FileTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type FileTransactorSession struct {
	Contract     *FileTransactor   // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// FileRaw is an auto generated low-level Go binding around an Ethereum contract.
type FileRaw struct {
	Contract *File // Generic contract binding to access the raw methods on
}

// FileCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type FileCallerRaw struct {
	Contract *FileCaller // Generic read-only contract binding to access the raw methods on
}

// FileTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type FileTransactorRaw struct {
	Contract *FileTransactor // Generic write-only contract binding to access the raw methods on
}

// NewFile creates a new instance of File, bound to a specific deployed contract.
func NewFile(address common.Address, backend bind.ContractBackend) (*File, error) {
	contract, err := bindFile(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &File{FileCaller: FileCaller{contract: contract}, FileTransactor: FileTransactor{contract: contract}, FileFilterer: FileFilterer{contract: contract}}, nil
}

// NewFileCaller creates a new read-only instance of File, bound to a specific deployed contract.
func NewFileCaller(address common.Address, caller bind.ContractCaller) (*FileCaller, error) {
	contract, err := bindFile(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &FileCaller{contract: contract}, nil
}

// NewFileTransactor creates a new write-only instance of File, bound to a specific deployed contract.
func NewFileTransactor(address common.Address, transactor bind.ContractTransactor) (*FileTransactor, error) {
	contract, err := bindFile(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &FileTransactor{contract: contract}, nil
}

// NewFileFilterer creates a new log filterer instance of File, bound to a specific deployed contract.
func NewFileFilterer(address common.Address, filterer bind.ContractFilterer) (*FileFilterer, error) {
	contract, err := bindFile(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &FileFilterer{contract: contract}, nil
}

// bindFile binds a generic wrapper to an already deployed contract.
func bindFile(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(FileABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_File *FileRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _File.Contract.FileCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_File *FileRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _File.Contract.FileTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_File *FileRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _File.Contract.FileTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_File *FileCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _File.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_File *FileTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _File.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_File *FileTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _File.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _a) view returns(uint256)
func (_File *FileCaller) BalanceOf(opts *bind.CallOpts, _a common.Address) (*big.Int, error) {
	var out []interface{}
	err := _File.contract.Call(opts, &out, "balanceOf", _a)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _a) view returns(uint256)
func (_File *FileSession) BalanceOf(_a common.Address) (*big.Int, error) {
	return _File.Contract.BalanceOf(&_File.CallOpts, _a)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _a) view returns(uint256)
func (_File *FileCallerSession) BalanceOf(_a common.Address) (*big.Int, error) {
	return _File.Contract.BalanceOf(&_File.CallOpts, _a)
}

// Bank is a free data retrieval call binding the contract method 0x76cdb03b.
//
// Solidity: function bank() view returns(address)
func (_File *FileCaller) Bank(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _File.contract.Call(opts, &out, "bank")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Bank is a free data retrieval call binding the contract method 0x76cdb03b.
//
// Solidity: function bank() view returns(address)
func (_File *FileSession) Bank() (common.Address, error) {
	return _File.Contract.Bank(&_File.CallOpts)
}

// Bank is a free data retrieval call binding the contract method 0x76cdb03b.
//
// Solidity: function bank() view returns(address)
func (_File *FileCallerSession) Bank() (common.Address, error) {
	return _File.Contract.Bank(&_File.CallOpts)
}

// Current is a free data retrieval call binding the contract method 0x9fa6a6e3.
//
// Solidity: function current() view returns(uint64)
func (_File *FileCaller) Current(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _File.contract.Call(opts, &out, "current")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// Current is a free data retrieval call binding the contract method 0x9fa6a6e3.
//
// Solidity: function current() view returns(uint64)
func (_File *FileSession) Current() (uint64, error) {
	return _File.Contract.Current(&_File.CallOpts)
}

// Current is a free data retrieval call binding the contract method 0x9fa6a6e3.
//
// Solidity: function current() view returns(uint64)
func (_File *FileCallerSession) Current() (uint64, error) {
	return _File.Contract.Current(&_File.CallOpts)
}

// Delay is a free data retrieval call binding the contract method 0x6a42b8f8.
//
// Solidity: function delay() view returns(uint64)
func (_File *FileCaller) Delay(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _File.contract.Call(opts, &out, "delay")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// Delay is a free data retrieval call binding the contract method 0x6a42b8f8.
//
// Solidity: function delay() view returns(uint64)
func (_File *FileSession) Delay() (uint64, error) {
	return _File.Contract.Delay(&_File.CallOpts)
}

// Delay is a free data retrieval call binding the contract method 0x6a42b8f8.
//
// Solidity: function delay() view returns(uint64)
func (_File *FileCallerSession) Delay() (uint64, error) {
	return _File.Contract.Delay(&_File.CallOpts)
}

// GetFile is a free data retrieval call binding the contract method 0xbb2d4d49.
//
// Solidity: function getFile(uint64 _fi) view returns((string,address,uint256,uint64,uint64,uint64) _fb)
func (_File *FileCaller) GetFile(opts *bind.CallOpts, _fi uint64) (IFileFileInfo, error) {
	var out []interface{}
	err := _File.contract.Call(opts, &out, "getFile", _fi)

	if err != nil {
		return *new(IFileFileInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(IFileFileInfo)).(*IFileFileInfo)

	return out0, err

}

// GetFile is a free data retrieval call binding the contract method 0xbb2d4d49.
//
// Solidity: function getFile(uint64 _fi) view returns((string,address,uint256,uint64,uint64,uint64) _fb)
func (_File *FileSession) GetFile(_fi uint64) (IFileFileInfo, error) {
	return _File.Contract.GetFile(&_File.CallOpts, _fi)
}

// GetFile is a free data retrieval call binding the contract method 0xbb2d4d49.
//
// Solidity: function getFile(uint64 _fi) view returns((string,address,uint256,uint64,uint64,uint64) _fb)
func (_File *FileCallerSession) GetFile(_fi uint64) (IFileFileInfo, error) {
	return _File.Contract.GetFile(&_File.CallOpts, _fi)
}

// GetFileIndex is a free data retrieval call binding the contract method 0x3a832ec8.
//
// Solidity: function getFileIndex(string _fn) view returns(uint64)
func (_File *FileCaller) GetFileIndex(opts *bind.CallOpts, _fn string) (uint64, error) {
	var out []interface{}
	err := _File.contract.Call(opts, &out, "getFileIndex", _fn)

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// GetFileIndex is a free data retrieval call binding the contract method 0x3a832ec8.
//
// Solidity: function getFileIndex(string _fn) view returns(uint64)
func (_File *FileSession) GetFileIndex(_fn string) (uint64, error) {
	return _File.Contract.GetFileIndex(&_File.CallOpts, _fn)
}

// GetFileIndex is a free data retrieval call binding the contract method 0x3a832ec8.
//
// Solidity: function getFileIndex(string _fn) view returns(uint64)
func (_File *FileCallerSession) GetFileIndex(_fn string) (uint64, error) {
	return _File.Contract.GetFileIndex(&_File.CallOpts, _fn)
}

// GetPiece is a free data retrieval call binding the contract method 0xdcc8922e.
//
// Solidity: function getPiece(uint64 _fi, uint64 _pi) view returns((bytes,uint64[]) _pinfo)
func (_File *FileCaller) GetPiece(opts *bind.CallOpts, _fi uint64, _pi uint64) (IFilePieceInfo, error) {
	var out []interface{}
	err := _File.contract.Call(opts, &out, "getPiece", _fi, _pi)

	if err != nil {
		return *new(IFilePieceInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(IFilePieceInfo)).(*IFilePieceInfo)

	return out0, err

}

// GetPiece is a free data retrieval call binding the contract method 0xdcc8922e.
//
// Solidity: function getPiece(uint64 _fi, uint64 _pi) view returns((bytes,uint64[]) _pinfo)
func (_File *FileSession) GetPiece(_fi uint64, _pi uint64) (IFilePieceInfo, error) {
	return _File.Contract.GetPiece(&_File.CallOpts, _fi, _pi)
}

// GetPiece is a free data retrieval call binding the contract method 0xdcc8922e.
//
// Solidity: function getPiece(uint64 _fi, uint64 _pi) view returns((bytes,uint64[]) _pinfo)
func (_File *FileCallerSession) GetPiece(_fi uint64, _pi uint64) (IFilePieceInfo, error) {
	return _File.Contract.GetPiece(&_File.CallOpts, _fi, _pi)
}

// GetPrepay is a free data retrieval call binding the contract method 0x6bbd5f87.
//
// Solidity: function getPrepay(uint64 _fi) view returns(uint256)
func (_File *FileCaller) GetPrepay(opts *bind.CallOpts, _fi uint64) (*big.Int, error) {
	var out []interface{}
	err := _File.contract.Call(opts, &out, "getPrepay", _fi)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetPrepay is a free data retrieval call binding the contract method 0x6bbd5f87.
//
// Solidity: function getPrepay(uint64 _fi) view returns(uint256)
func (_File *FileSession) GetPrepay(_fi uint64) (*big.Int, error) {
	return _File.Contract.GetPrepay(&_File.CallOpts, _fi)
}

// GetPrepay is a free data retrieval call binding the contract method 0x6bbd5f87.
//
// Solidity: function getPrepay(uint64 _fi) view returns(uint256)
func (_File *FileCallerSession) GetPrepay(_fi uint64) (*big.Int, error) {
	return _File.Contract.GetPrepay(&_File.CallOpts, _fi)
}

// GetRExpire is a free data retrieval call binding the contract method 0xaccbe33b.
//
// Solidity: function getRExpire(bytes _r) view returns(uint64)
func (_File *FileCaller) GetRExpire(opts *bind.CallOpts, _r []byte) (uint64, error) {
	var out []interface{}
	err := _File.contract.Call(opts, &out, "getRExpire", _r)

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// GetRExpire is a free data retrieval call binding the contract method 0xaccbe33b.
//
// Solidity: function getRExpire(bytes _r) view returns(uint64)
func (_File *FileSession) GetRExpire(_r []byte) (uint64, error) {
	return _File.Contract.GetRExpire(&_File.CallOpts, _r)
}

// GetRExpire is a free data retrieval call binding the contract method 0xaccbe33b.
//
// Solidity: function getRExpire(bytes _r) view returns(uint64)
func (_File *FileCallerSession) GetRExpire(_r []byte) (uint64, error) {
	return _File.Contract.GetRExpire(&_File.CallOpts, _r)
}

// GetReplica is a free data retrieval call binding the contract method 0x9108544c.
//
// Solidity: function getReplica(uint64 _r) view returns((bytes,uint64,address) _ri)
func (_File *FileCaller) GetReplica(opts *bind.CallOpts, _r uint64) (IFileReplicaInfo, error) {
	var out []interface{}
	err := _File.contract.Call(opts, &out, "getReplica", _r)

	if err != nil {
		return *new(IFileReplicaInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(IFileReplicaInfo)).(*IFileReplicaInfo)

	return out0, err

}

// GetReplica is a free data retrieval call binding the contract method 0x9108544c.
//
// Solidity: function getReplica(uint64 _r) view returns((bytes,uint64,address) _ri)
func (_File *FileSession) GetReplica(_r uint64) (IFileReplicaInfo, error) {
	return _File.Contract.GetReplica(&_File.CallOpts, _r)
}

// GetReplica is a free data retrieval call binding the contract method 0x9108544c.
//
// Solidity: function getReplica(uint64 _r) view returns((bytes,uint64,address) _ri)
func (_File *FileCallerSession) GetReplica(_r uint64) (IFileReplicaInfo, error) {
	return _File.Contract.GetReplica(&_File.CallOpts, _r)
}

// GetReplicaIndex is a free data retrieval call binding the contract method 0x386e6da6.
//
// Solidity: function getReplicaIndex(bytes _rn) view returns(uint64)
func (_File *FileCaller) GetReplicaIndex(opts *bind.CallOpts, _rn []byte) (uint64, error) {
	var out []interface{}
	err := _File.contract.Call(opts, &out, "getReplicaIndex", _rn)

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// GetReplicaIndex is a free data retrieval call binding the contract method 0x386e6da6.
//
// Solidity: function getReplicaIndex(bytes _rn) view returns(uint64)
func (_File *FileSession) GetReplicaIndex(_rn []byte) (uint64, error) {
	return _File.Contract.GetReplicaIndex(&_File.CallOpts, _rn)
}

// GetReplicaIndex is a free data retrieval call binding the contract method 0x386e6da6.
//
// Solidity: function getReplicaIndex(bytes _rn) view returns(uint64)
func (_File *FileCallerSession) GetReplicaIndex(_rn []byte) (uint64, error) {
	return _File.Contract.GetReplicaIndex(&_File.CallOpts, _rn)
}

// GetSReplica is a free data retrieval call binding the contract method 0x6f3e37b1.
//
// Solidity: function getSReplica(address _a, uint64 _ri) view returns(bytes _r)
func (_File *FileCaller) GetSReplica(opts *bind.CallOpts, _a common.Address, _ri uint64) ([]byte, error) {
	var out []interface{}
	err := _File.contract.Call(opts, &out, "getSReplica", _a, _ri)

	if err != nil {
		return *new([]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([]byte)).(*[]byte)

	return out0, err

}

// GetSReplica is a free data retrieval call binding the contract method 0x6f3e37b1.
//
// Solidity: function getSReplica(address _a, uint64 _ri) view returns(bytes _r)
func (_File *FileSession) GetSReplica(_a common.Address, _ri uint64) ([]byte, error) {
	return _File.Contract.GetSReplica(&_File.CallOpts, _a, _ri)
}

// GetSReplica is a free data retrieval call binding the contract method 0x6f3e37b1.
//
// Solidity: function getSReplica(address _a, uint64 _ri) view returns(bytes _r)
func (_File *FileCallerSession) GetSReplica(_a common.Address, _ri uint64) ([]byte, error) {
	return _File.Contract.GetSReplica(&_File.CallOpts, _a, _ri)
}

// GetSStat is a free data retrieval call binding the contract method 0xc3aa3804.
//
// Solidity: function getSStat(address _a, uint64 _e) view returns((uint64,uint64,uint256) _si)
func (_File *FileCaller) GetSStat(opts *bind.CallOpts, _a common.Address, _e uint64) (IFileStoreStat, error) {
	var out []interface{}
	err := _File.contract.Call(opts, &out, "getSStat", _a, _e)

	if err != nil {
		return *new(IFileStoreStat), err
	}

	out0 := *abi.ConvertType(out[0], new(IFileStoreStat)).(*IFileStoreStat)

	return out0, err

}

// GetSStat is a free data retrieval call binding the contract method 0xc3aa3804.
//
// Solidity: function getSStat(address _a, uint64 _e) view returns((uint64,uint64,uint256) _si)
func (_File *FileSession) GetSStat(_a common.Address, _e uint64) (IFileStoreStat, error) {
	return _File.Contract.GetSStat(&_File.CallOpts, _a, _e)
}

// GetSStat is a free data retrieval call binding the contract method 0xc3aa3804.
//
// Solidity: function getSStat(address _a, uint64 _e) view returns((uint64,uint64,uint256) _si)
func (_File *FileCallerSession) GetSStat(_a common.Address, _e uint64) (IFileStoreStat, error) {
	return _File.Contract.GetSStat(&_File.CallOpts, _a, _e)
}

// GetStore is a free data retrieval call binding the contract method 0x4b4ffccd.
//
// Solidity: function getStore(address _a) view returns((uint64,uint64,uint64,uint256) _si)
func (_File *FileCaller) GetStore(opts *bind.CallOpts, _a common.Address) (IFileStoreInfo, error) {
	var out []interface{}
	err := _File.contract.Call(opts, &out, "getStore", _a)

	if err != nil {
		return *new(IFileStoreInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(IFileStoreInfo)).(*IFileStoreInfo)

	return out0, err

}

// GetStore is a free data retrieval call binding the contract method 0x4b4ffccd.
//
// Solidity: function getStore(address _a) view returns((uint64,uint64,uint64,uint256) _si)
func (_File *FileSession) GetStore(_a common.Address) (IFileStoreInfo, error) {
	return _File.Contract.GetStore(&_File.CallOpts, _a)
}

// GetStore is a free data retrieval call binding the contract method 0x4b4ffccd.
//
// Solidity: function getStore(address _a) view returns((uint64,uint64,uint64,uint256) _si)
func (_File *FileCallerSession) GetStore(_a common.Address) (IFileStoreInfo, error) {
	return _File.Contract.GetStore(&_File.CallOpts, _a)
}

// GetStoreAt is a free data retrieval call binding the contract method 0x6150ad81.
//
// Solidity: function getStoreAt(address _a, uint64 _e) view returns(uint64, uint64)
func (_File *FileCaller) GetStoreAt(opts *bind.CallOpts, _a common.Address, _e uint64) (uint64, uint64, error) {
	var out []interface{}
	err := _File.contract.Call(opts, &out, "getStoreAt", _a, _e)

	if err != nil {
		return *new(uint64), *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)
	out1 := *abi.ConvertType(out[1], new(uint64)).(*uint64)

	return out0, out1, err

}

// GetStoreAt is a free data retrieval call binding the contract method 0x6150ad81.
//
// Solidity: function getStoreAt(address _a, uint64 _e) view returns(uint64, uint64)
func (_File *FileSession) GetStoreAt(_a common.Address, _e uint64) (uint64, uint64, error) {
	return _File.Contract.GetStoreAt(&_File.CallOpts, _a, _e)
}

// GetStoreAt is a free data retrieval call binding the contract method 0x6150ad81.
//
// Solidity: function getStoreAt(address _a, uint64 _e) view returns(uint64, uint64)
func (_File *FileCallerSession) GetStoreAt(_a common.Address, _e uint64) (uint64, uint64, error) {
	return _File.Contract.GetStoreAt(&_File.CallOpts, _a, _e)
}

// IsAgent is a free data retrieval call binding the contract method 0xe5107912.
//
// Solidity: function isAgent(uint64 _fi, address _a) view returns(bool)
func (_File *FileCaller) IsAgent(opts *bind.CallOpts, _fi uint64, _a common.Address) (bool, error) {
	var out []interface{}
	err := _File.contract.Call(opts, &out, "isAgent", _fi, _a)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsAgent is a free data retrieval call binding the contract method 0xe5107912.
//
// Solidity: function isAgent(uint64 _fi, address _a) view returns(bool)
func (_File *FileSession) IsAgent(_fi uint64, _a common.Address) (bool, error) {
	return _File.Contract.IsAgent(&_File.CallOpts, _fi, _a)
}

// IsAgent is a free data retrieval call binding the contract method 0xe5107912.
//
// Solidity: function isAgent(uint64 _fi, address _a) view returns(bool)
func (_File *FileCallerSession) IsAgent(_fi uint64, _a common.Address) (bool, error) {
	return _File.Contract.IsAgent(&_File.CallOpts, _fi, _a)
}

// MaxStore is a free data retrieval call binding the contract method 0xfca5be7a.
//
// Solidity: function maxStore() view returns(uint64)
func (_File *FileCaller) MaxStore(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _File.contract.Call(opts, &out, "maxStore")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// MaxStore is a free data retrieval call binding the contract method 0xfca5be7a.
//
// Solidity: function maxStore() view returns(uint64)
func (_File *FileSession) MaxStore() (uint64, error) {
	return _File.Contract.MaxStore(&_File.CallOpts)
}

// MaxStore is a free data retrieval call binding the contract method 0xfca5be7a.
//
// Solidity: function maxStore() view returns(uint64)
func (_File *FileCallerSession) MaxStore() (uint64, error) {
	return _File.Contract.MaxStore(&_File.CallOpts)
}

// MinStore is a free data retrieval call binding the contract method 0x88795125.
//
// Solidity: function minStore() view returns(uint64)
func (_File *FileCaller) MinStore(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _File.contract.Call(opts, &out, "minStore")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// MinStore is a free data retrieval call binding the contract method 0x88795125.
//
// Solidity: function minStore() view returns(uint64)
func (_File *FileSession) MinStore() (uint64, error) {
	return _File.Contract.MinStore(&_File.CallOpts)
}

// MinStore is a free data retrieval call binding the contract method 0x88795125.
//
// Solidity: function minStore() view returns(uint64)
func (_File *FileCallerSession) MinStore() (uint64, error) {
	return _File.Contract.MinStore(&_File.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_File *FileCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _File.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_File *FileSession) Owner() (common.Address, error) {
	return _File.Contract.Owner(&_File.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_File *FileCallerSession) Owner() (common.Address, error) {
	return _File.Contract.Owner(&_File.CallOpts)
}

// Reward is a free data retrieval call binding the contract method 0x228cb733.
//
// Solidity: function reward() view returns(uint256)
func (_File *FileCaller) Reward(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _File.contract.Call(opts, &out, "reward")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Reward is a free data retrieval call binding the contract method 0x228cb733.
//
// Solidity: function reward() view returns(uint256)
func (_File *FileSession) Reward() (*big.Int, error) {
	return _File.Contract.Reward(&_File.CallOpts)
}

// Reward is a free data retrieval call binding the contract method 0x228cb733.
//
// Solidity: function reward() view returns(uint256)
func (_File *FileCallerSession) Reward() (*big.Int, error) {
	return _File.Contract.Reward(&_File.CallOpts)
}

// AddFile is a paid mutator transaction binding the contract method 0xc1c2e09c.
//
// Solidity: function addFile(string _fn, uint256 _p, uint64 _e) returns()
func (_File *FileTransactor) AddFile(opts *bind.TransactOpts, _fn string, _p *big.Int, _e uint64) (*types.Transaction, error) {
	return _File.contract.Transact(opts, "addFile", _fn, _p, _e)
}

// AddFile is a paid mutator transaction binding the contract method 0xc1c2e09c.
//
// Solidity: function addFile(string _fn, uint256 _p, uint64 _e) returns()
func (_File *FileSession) AddFile(_fn string, _p *big.Int, _e uint64) (*types.Transaction, error) {
	return _File.Contract.AddFile(&_File.TransactOpts, _fn, _p, _e)
}

// AddFile is a paid mutator transaction binding the contract method 0xc1c2e09c.
//
// Solidity: function addFile(string _fn, uint256 _p, uint64 _e) returns()
func (_File *FileTransactorSession) AddFile(_fn string, _p *big.Int, _e uint64) (*types.Transaction, error) {
	return _File.Contract.AddFile(&_File.TransactOpts, _fn, _p, _e)
}

// AddPiece is a paid mutator transaction binding the contract method 0x84826517.
//
// Solidity: function addPiece(uint64 _fi, bytes[] _piece) returns()
func (_File *FileTransactor) AddPiece(opts *bind.TransactOpts, _fi uint64, _piece [][]byte) (*types.Transaction, error) {
	return _File.contract.Transact(opts, "addPiece", _fi, _piece)
}

// AddPiece is a paid mutator transaction binding the contract method 0x84826517.
//
// Solidity: function addPiece(uint64 _fi, bytes[] _piece) returns()
func (_File *FileSession) AddPiece(_fi uint64, _piece [][]byte) (*types.Transaction, error) {
	return _File.Contract.AddPiece(&_File.TransactOpts, _fi, _piece)
}

// AddPiece is a paid mutator transaction binding the contract method 0x84826517.
//
// Solidity: function addPiece(uint64 _fi, bytes[] _piece) returns()
func (_File *FileTransactorSession) AddPiece(_fi uint64, _piece [][]byte) (*types.Transaction, error) {
	return _File.Contract.AddPiece(&_File.TransactOpts, _fi, _piece)
}

// AddReplica is a paid mutator transaction binding the contract method 0x91601d9e.
//
// Solidity: function addReplica(uint64 _fi, uint64 _pi, bytes _rn, bytes _sign) returns()
func (_File *FileTransactor) AddReplica(opts *bind.TransactOpts, _fi uint64, _pi uint64, _rn []byte, _sign []byte) (*types.Transaction, error) {
	return _File.contract.Transact(opts, "addReplica", _fi, _pi, _rn, _sign)
}

// AddReplica is a paid mutator transaction binding the contract method 0x91601d9e.
//
// Solidity: function addReplica(uint64 _fi, uint64 _pi, bytes _rn, bytes _sign) returns()
func (_File *FileSession) AddReplica(_fi uint64, _pi uint64, _rn []byte, _sign []byte) (*types.Transaction, error) {
	return _File.Contract.AddReplica(&_File.TransactOpts, _fi, _pi, _rn, _sign)
}

// AddReplica is a paid mutator transaction binding the contract method 0x91601d9e.
//
// Solidity: function addReplica(uint64 _fi, uint64 _pi, bytes _rn, bytes _sign) returns()
func (_File *FileTransactorSession) AddReplica(_fi uint64, _pi uint64, _rn []byte, _sign []byte) (*types.Transaction, error) {
	return _File.Contract.AddReplica(&_File.TransactOpts, _fi, _pi, _rn, _sign)
}

// PrePay is a paid mutator transaction binding the contract method 0x6c050b38.
//
// Solidity: function prePay(uint64 _fi, uint256 _m) returns()
func (_File *FileTransactor) PrePay(opts *bind.TransactOpts, _fi uint64, _m *big.Int) (*types.Transaction, error) {
	return _File.contract.Transact(opts, "prePay", _fi, _m)
}

// PrePay is a paid mutator transaction binding the contract method 0x6c050b38.
//
// Solidity: function prePay(uint64 _fi, uint256 _m) returns()
func (_File *FileSession) PrePay(_fi uint64, _m *big.Int) (*types.Transaction, error) {
	return _File.Contract.PrePay(&_File.TransactOpts, _fi, _m)
}

// PrePay is a paid mutator transaction binding the contract method 0x6c050b38.
//
// Solidity: function prePay(uint64 _fi, uint256 _m) returns()
func (_File *FileTransactorSession) PrePay(_fi uint64, _m *big.Int) (*types.Transaction, error) {
	return _File.Contract.PrePay(&_File.TransactOpts, _fi, _m)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_File *FileTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _File.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_File *FileSession) RenounceOwnership() (*types.Transaction, error) {
	return _File.Contract.RenounceOwnership(&_File.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_File *FileTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _File.Contract.RenounceOwnership(&_File.TransactOpts)
}

// SetAgent is a paid mutator transaction binding the contract method 0x134cd2bd.
//
// Solidity: function setAgent(uint64 _fi, address _p) returns()
func (_File *FileTransactor) SetAgent(opts *bind.TransactOpts, _fi uint64, _p common.Address) (*types.Transaction, error) {
	return _File.contract.Transact(opts, "setAgent", _fi, _p)
}

// SetAgent is a paid mutator transaction binding the contract method 0x134cd2bd.
//
// Solidity: function setAgent(uint64 _fi, address _p) returns()
func (_File *FileSession) SetAgent(_fi uint64, _p common.Address) (*types.Transaction, error) {
	return _File.Contract.SetAgent(&_File.TransactOpts, _fi, _p)
}

// SetAgent is a paid mutator transaction binding the contract method 0x134cd2bd.
//
// Solidity: function setAgent(uint64 _fi, address _p) returns()
func (_File *FileTransactorSession) SetAgent(_fi uint64, _p common.Address) (*types.Transaction, error) {
	return _File.Contract.SetAgent(&_File.TransactOpts, _fi, _p)
}

// Settle is a paid mutator transaction binding the contract method 0x4b9ba446.
//
// Solidity: function settle(uint64 _ep) returns()
func (_File *FileTransactor) Settle(opts *bind.TransactOpts, _ep uint64) (*types.Transaction, error) {
	return _File.contract.Transact(opts, "settle", _ep)
}

// Settle is a paid mutator transaction binding the contract method 0x4b9ba446.
//
// Solidity: function settle(uint64 _ep) returns()
func (_File *FileSession) Settle(_ep uint64) (*types.Transaction, error) {
	return _File.Contract.Settle(&_File.TransactOpts, _ep)
}

// Settle is a paid mutator transaction binding the contract method 0x4b9ba446.
//
// Solidity: function settle(uint64 _ep) returns()
func (_File *FileTransactorSession) Settle(_ep uint64) (*types.Transaction, error) {
	return _File.Contract.Settle(&_File.TransactOpts, _ep)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_File *FileTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _File.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_File *FileSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _File.Contract.TransferOwnership(&_File.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_File *FileTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _File.Contract.TransferOwnership(&_File.TransactOpts, newOwner)
}

// Withdraw is a paid mutator transaction binding the contract method 0x2e1a7d4d.
//
// Solidity: function withdraw(uint256 _m) returns()
func (_File *FileTransactor) Withdraw(opts *bind.TransactOpts, _m *big.Int) (*types.Transaction, error) {
	return _File.contract.Transact(opts, "withdraw", _m)
}

// Withdraw is a paid mutator transaction binding the contract method 0x2e1a7d4d.
//
// Solidity: function withdraw(uint256 _m) returns()
func (_File *FileSession) Withdraw(_m *big.Int) (*types.Transaction, error) {
	return _File.Contract.Withdraw(&_File.TransactOpts, _m)
}

// Withdraw is a paid mutator transaction binding the contract method 0x2e1a7d4d.
//
// Solidity: function withdraw(uint256 _m) returns()
func (_File *FileTransactorSession) Withdraw(_m *big.Int) (*types.Transaction, error) {
	return _File.Contract.Withdraw(&_File.TransactOpts, _m)
}

// WithdrawPrepay is a paid mutator transaction binding the contract method 0x4abeafd8.
//
// Solidity: function withdrawPrepay(uint64 _fi) returns()
func (_File *FileTransactor) WithdrawPrepay(opts *bind.TransactOpts, _fi uint64) (*types.Transaction, error) {
	return _File.contract.Transact(opts, "withdrawPrepay", _fi)
}

// WithdrawPrepay is a paid mutator transaction binding the contract method 0x4abeafd8.
//
// Solidity: function withdrawPrepay(uint64 _fi) returns()
func (_File *FileSession) WithdrawPrepay(_fi uint64) (*types.Transaction, error) {
	return _File.Contract.WithdrawPrepay(&_File.TransactOpts, _fi)
}

// WithdrawPrepay is a paid mutator transaction binding the contract method 0x4abeafd8.
//
// Solidity: function withdrawPrepay(uint64 _fi) returns()
func (_File *FileTransactorSession) WithdrawPrepay(_fi uint64) (*types.Transaction, error) {
	return _File.Contract.WithdrawPrepay(&_File.TransactOpts, _fi)
}

// FileAddFileIterator is returned from FilterAddFile and is used to iterate over the raw logs and unpacked data for AddFile events raised by the File contract.
type FileAddFileIterator struct {
	Event *FileAddFile // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FileAddFileIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FileAddFile)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FileAddFile)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FileAddFileIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FileAddFileIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FileAddFile represents a AddFile event raised by the File contract.
type FileAddFile struct {
	A   common.Address
	Fi  uint64
	Fn  string
	Raw types.Log // Blockchain specific contextual infos
}

// FilterAddFile is a free log retrieval operation binding the contract event 0x97fbaabf7920b8891ffb1c0610284ba7fc4b47b0f7ba084b2e634d496da89d29.
//
// Solidity: event AddFile(address indexed _a, uint64 _fi, string _fn)
func (_File *FileFilterer) FilterAddFile(opts *bind.FilterOpts, _a []common.Address) (*FileAddFileIterator, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _File.contract.FilterLogs(opts, "AddFile", _aRule)
	if err != nil {
		return nil, err
	}
	return &FileAddFileIterator{contract: _File.contract, event: "AddFile", logs: logs, sub: sub}, nil
}

// WatchAddFile is a free log subscription operation binding the contract event 0x97fbaabf7920b8891ffb1c0610284ba7fc4b47b0f7ba084b2e634d496da89d29.
//
// Solidity: event AddFile(address indexed _a, uint64 _fi, string _fn)
func (_File *FileFilterer) WatchAddFile(opts *bind.WatchOpts, sink chan<- *FileAddFile, _a []common.Address) (event.Subscription, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _File.contract.WatchLogs(opts, "AddFile", _aRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FileAddFile)
				if err := _File.contract.UnpackLog(event, "AddFile", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAddFile is a log parse operation binding the contract event 0x97fbaabf7920b8891ffb1c0610284ba7fc4b47b0f7ba084b2e634d496da89d29.
//
// Solidity: event AddFile(address indexed _a, uint64 _fi, string _fn)
func (_File *FileFilterer) ParseAddFile(log types.Log) (*FileAddFile, error) {
	event := new(FileAddFile)
	if err := _File.contract.UnpackLog(event, "AddFile", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FileAddPieceIterator is returned from FilterAddPiece and is used to iterate over the raw logs and unpacked data for AddPiece events raised by the File contract.
type FileAddPieceIterator struct {
	Event *FileAddPiece // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FileAddPieceIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FileAddPiece)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FileAddPiece)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FileAddPieceIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FileAddPieceIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FileAddPiece represents a AddPiece event raised by the File contract.
type FileAddPiece struct {
	Fi    uint64
	Pi    uint64
	Piece []byte
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterAddPiece is a free log retrieval operation binding the contract event 0xb121db726a172f87e0af2ba7bf7351c89c3d578b2b329f421b823e7f159f453a.
//
// Solidity: event AddPiece(uint64 _fi, uint64 _pi, bytes _piece)
func (_File *FileFilterer) FilterAddPiece(opts *bind.FilterOpts) (*FileAddPieceIterator, error) {

	logs, sub, err := _File.contract.FilterLogs(opts, "AddPiece")
	if err != nil {
		return nil, err
	}
	return &FileAddPieceIterator{contract: _File.contract, event: "AddPiece", logs: logs, sub: sub}, nil
}

// WatchAddPiece is a free log subscription operation binding the contract event 0xb121db726a172f87e0af2ba7bf7351c89c3d578b2b329f421b823e7f159f453a.
//
// Solidity: event AddPiece(uint64 _fi, uint64 _pi, bytes _piece)
func (_File *FileFilterer) WatchAddPiece(opts *bind.WatchOpts, sink chan<- *FileAddPiece) (event.Subscription, error) {

	logs, sub, err := _File.contract.WatchLogs(opts, "AddPiece")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FileAddPiece)
				if err := _File.contract.UnpackLog(event, "AddPiece", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAddPiece is a log parse operation binding the contract event 0xb121db726a172f87e0af2ba7bf7351c89c3d578b2b329f421b823e7f159f453a.
//
// Solidity: event AddPiece(uint64 _fi, uint64 _pi, bytes _piece)
func (_File *FileFilterer) ParseAddPiece(log types.Log) (*FileAddPiece, error) {
	event := new(FileAddPiece)
	if err := _File.contract.UnpackLog(event, "AddPiece", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FileAddReplicaIterator is returned from FilterAddReplica and is used to iterate over the raw logs and unpacked data for AddReplica events raised by the File contract.
type FileAddReplicaIterator struct {
	Event *FileAddReplica // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FileAddReplicaIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FileAddReplica)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FileAddReplica)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FileAddReplicaIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FileAddReplicaIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FileAddReplica represents a AddReplica event raised by the File contract.
type FileAddReplica struct {
	A   common.Address
	Fi  uint64
	Pi  uint64
	Ri  uint64
	Rn  []byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterAddReplica is a free log retrieval operation binding the contract event 0x9ad879f74989d3436fd7b3ab155a0d4af6ae45b6f98d91513e1398e0bc3afa15.
//
// Solidity: event AddReplica(address indexed _a, uint64 _fi, uint64 _pi, uint64 _ri, bytes _rn)
func (_File *FileFilterer) FilterAddReplica(opts *bind.FilterOpts, _a []common.Address) (*FileAddReplicaIterator, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _File.contract.FilterLogs(opts, "AddReplica", _aRule)
	if err != nil {
		return nil, err
	}
	return &FileAddReplicaIterator{contract: _File.contract, event: "AddReplica", logs: logs, sub: sub}, nil
}

// WatchAddReplica is a free log subscription operation binding the contract event 0x9ad879f74989d3436fd7b3ab155a0d4af6ae45b6f98d91513e1398e0bc3afa15.
//
// Solidity: event AddReplica(address indexed _a, uint64 _fi, uint64 _pi, uint64 _ri, bytes _rn)
func (_File *FileFilterer) WatchAddReplica(opts *bind.WatchOpts, sink chan<- *FileAddReplica, _a []common.Address) (event.Subscription, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _File.contract.WatchLogs(opts, "AddReplica", _aRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FileAddReplica)
				if err := _File.contract.UnpackLog(event, "AddReplica", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAddReplica is a log parse operation binding the contract event 0x9ad879f74989d3436fd7b3ab155a0d4af6ae45b6f98d91513e1398e0bc3afa15.
//
// Solidity: event AddReplica(address indexed _a, uint64 _fi, uint64 _pi, uint64 _ri, bytes _rn)
func (_File *FileFilterer) ParseAddReplica(log types.Log) (*FileAddReplica, error) {
	event := new(FileAddReplica)
	if err := _File.contract.UnpackLog(event, "AddReplica", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FileOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the File contract.
type FileOwnershipTransferredIterator struct {
	Event *FileOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FileOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FileOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FileOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FileOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FileOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FileOwnershipTransferred represents a OwnershipTransferred event raised by the File contract.
type FileOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_File *FileFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*FileOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _File.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &FileOwnershipTransferredIterator{contract: _File.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_File *FileFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *FileOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _File.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FileOwnershipTransferred)
				if err := _File.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_File *FileFilterer) ParseOwnershipTransferred(log types.Log) (*FileOwnershipTransferred, error) {
	event := new(FileOwnershipTransferred)
	if err := _File.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FileSettleIterator is returned from FilterSettle and is used to iterate over the raw logs and unpacked data for Settle events raised by the File contract.
type FileSettleIterator struct {
	Event *FileSettle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FileSettleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FileSettle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FileSettle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FileSettleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FileSettleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FileSettle represents a Settle event raised by the File contract.
type FileSettle struct {
	A   common.Address
	E   uint64
	M   *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterSettle is a free log retrieval operation binding the contract event 0x22b9b452d488700bdfeab2aa62972ac1fce3160583db89ab4c799708bf5a2c6c.
//
// Solidity: event Settle(address indexed _a, uint64 _e, uint256 _m)
func (_File *FileFilterer) FilterSettle(opts *bind.FilterOpts, _a []common.Address) (*FileSettleIterator, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _File.contract.FilterLogs(opts, "Settle", _aRule)
	if err != nil {
		return nil, err
	}
	return &FileSettleIterator{contract: _File.contract, event: "Settle", logs: logs, sub: sub}, nil
}

// WatchSettle is a free log subscription operation binding the contract event 0x22b9b452d488700bdfeab2aa62972ac1fce3160583db89ab4c799708bf5a2c6c.
//
// Solidity: event Settle(address indexed _a, uint64 _e, uint256 _m)
func (_File *FileFilterer) WatchSettle(opts *bind.WatchOpts, sink chan<- *FileSettle, _a []common.Address) (event.Subscription, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _File.contract.WatchLogs(opts, "Settle", _aRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FileSettle)
				if err := _File.contract.UnpackLog(event, "Settle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSettle is a log parse operation binding the contract event 0x22b9b452d488700bdfeab2aa62972ac1fce3160583db89ab4c799708bf5a2c6c.
//
// Solidity: event Settle(address indexed _a, uint64 _e, uint256 _m)
func (_File *FileFilterer) ParseSettle(log types.Log) (*FileSettle, error) {
	event := new(FileSettle)
	if err := _File.contract.UnpackLog(event, "Settle", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FileWithdrawIterator is returned from FilterWithdraw and is used to iterate over the raw logs and unpacked data for Withdraw events raised by the File contract.
type FileWithdrawIterator struct {
	Event *FileWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FileWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FileWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FileWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FileWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FileWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FileWithdraw represents a Withdraw event raised by the File contract.
type FileWithdraw struct {
	A   common.Address
	M   *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterWithdraw is a free log retrieval operation binding the contract event 0x884edad9ce6fa2440d8a54cc123490eb96d2768479d49ff9c7366125a9424364.
//
// Solidity: event Withdraw(address indexed _a, uint256 _m)
func (_File *FileFilterer) FilterWithdraw(opts *bind.FilterOpts, _a []common.Address) (*FileWithdrawIterator, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _File.contract.FilterLogs(opts, "Withdraw", _aRule)
	if err != nil {
		return nil, err
	}
	return &FileWithdrawIterator{contract: _File.contract, event: "Withdraw", logs: logs, sub: sub}, nil
}

// WatchWithdraw is a free log subscription operation binding the contract event 0x884edad9ce6fa2440d8a54cc123490eb96d2768479d49ff9c7366125a9424364.
//
// Solidity: event Withdraw(address indexed _a, uint256 _m)
func (_File *FileFilterer) WatchWithdraw(opts *bind.WatchOpts, sink chan<- *FileWithdraw, _a []common.Address) (event.Subscription, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _File.contract.WatchLogs(opts, "Withdraw", _aRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FileWithdraw)
				if err := _File.contract.UnpackLog(event, "Withdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdraw is a log parse operation binding the contract event 0x884edad9ce6fa2440d8a54cc123490eb96d2768479d49ff9c7366125a9424364.
//
// Solidity: event Withdraw(address indexed _a, uint256 _m)
func (_File *FileFilterer) ParseWithdraw(log types.Log) (*FileWithdraw, error) {
	event := new(FileWithdraw)
	if err := _File.contract.UnpackLog(event, "Withdraw", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IBankABI is the input ABI used to generate the binding from.
const IBankABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_m\",\"type\":\"uint256\"}],\"name\":\"Migrate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_m\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"_s\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"Set\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_m\",\"type\":\"uint256\"}],\"name\":\"TransferIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_m\",\"type\":\"uint256\"}],\"name\":\"TransferOut\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_s\",\"type\":\"string\"}],\"name\":\"get\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_m\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_s\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_m\",\"type\":\"uint256\"}],\"name\":\"transferIn\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_m\",\"type\":\"uint256\"}],\"name\":\"transferOut\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]"

// IBankFuncSigs maps the 4-byte function signature to its string representation.
var IBankFuncSigs = map[string]string{
	"693ec85e": "get(string)",
	"ce5494bb": "migrate(address)",
	"40c10f19": "mint(address,uint256)",
	"a815ff15": "set(string,address)",
	"e8888915": "transferIn(address,uint256)",
	"76890c58": "transferOut(address,uint256)",
}

// IBank is an auto generated Go binding around an Ethereum contract.
type IBank struct {
	IBankCaller     // Read-only binding to the contract
	IBankTransactor // Write-only binding to the contract
	IBankFilterer   // Log filterer for contract events
}

// IBankCaller is an auto generated read-only Go binding around an Ethereum contract.
type IBankCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBankTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IBankTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBankFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IBankFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBankSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IBankSession struct {
	Contract     *IBank            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IBankCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IBankCallerSession struct {
	Contract *IBankCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// IBankTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IBankTransactorSession struct {
	Contract     *IBankTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IBankRaw is an auto generated low-level Go binding around an Ethereum contract.
type IBankRaw struct {
	Contract *IBank // Generic contract binding to access the raw methods on
}

// IBankCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IBankCallerRaw struct {
	Contract *IBankCaller // Generic read-only contract binding to access the raw methods on
}

// IBankTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IBankTransactorRaw struct {
	Contract *IBankTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIBank creates a new instance of IBank, bound to a specific deployed contract.
func NewIBank(address common.Address, backend bind.ContractBackend) (*IBank, error) {
	contract, err := bindIBank(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IBank{IBankCaller: IBankCaller{contract: contract}, IBankTransactor: IBankTransactor{contract: contract}, IBankFilterer: IBankFilterer{contract: contract}}, nil
}

// NewIBankCaller creates a new read-only instance of IBank, bound to a specific deployed contract.
func NewIBankCaller(address common.Address, caller bind.ContractCaller) (*IBankCaller, error) {
	contract, err := bindIBank(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IBankCaller{contract: contract}, nil
}

// NewIBankTransactor creates a new write-only instance of IBank, bound to a specific deployed contract.
func NewIBankTransactor(address common.Address, transactor bind.ContractTransactor) (*IBankTransactor, error) {
	contract, err := bindIBank(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IBankTransactor{contract: contract}, nil
}

// NewIBankFilterer creates a new log filterer instance of IBank, bound to a specific deployed contract.
func NewIBankFilterer(address common.Address, filterer bind.ContractFilterer) (*IBankFilterer, error) {
	contract, err := bindIBank(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IBankFilterer{contract: contract}, nil
}

// bindIBank binds a generic wrapper to an already deployed contract.
func bindIBank(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IBankABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBank *IBankRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBank.Contract.IBankCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBank *IBankRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBank.Contract.IBankTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBank *IBankRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBank.Contract.IBankTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBank *IBankCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBank.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBank *IBankTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBank.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBank *IBankTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBank.Contract.contract.Transact(opts, method, params...)
}

// Get is a paid mutator transaction binding the contract method 0x693ec85e.
//
// Solidity: function get(string _s) returns(address)
func (_IBank *IBankTransactor) Get(opts *bind.TransactOpts, _s string) (*types.Transaction, error) {
	return _IBank.contract.Transact(opts, "get", _s)
}

// Get is a paid mutator transaction binding the contract method 0x693ec85e.
//
// Solidity: function get(string _s) returns(address)
func (_IBank *IBankSession) Get(_s string) (*types.Transaction, error) {
	return _IBank.Contract.Get(&_IBank.TransactOpts, _s)
}

// Get is a paid mutator transaction binding the contract method 0x693ec85e.
//
// Solidity: function get(string _s) returns(address)
func (_IBank *IBankTransactorSession) Get(_s string) (*types.Transaction, error) {
	return _IBank.Contract.Get(&_IBank.TransactOpts, _s)
}

// Migrate is a paid mutator transaction binding the contract method 0xce5494bb.
//
// Solidity: function migrate(address _a) returns()
func (_IBank *IBankTransactor) Migrate(opts *bind.TransactOpts, _a common.Address) (*types.Transaction, error) {
	return _IBank.contract.Transact(opts, "migrate", _a)
}

// Migrate is a paid mutator transaction binding the contract method 0xce5494bb.
//
// Solidity: function migrate(address _a) returns()
func (_IBank *IBankSession) Migrate(_a common.Address) (*types.Transaction, error) {
	return _IBank.Contract.Migrate(&_IBank.TransactOpts, _a)
}

// Migrate is a paid mutator transaction binding the contract method 0xce5494bb.
//
// Solidity: function migrate(address _a) returns()
func (_IBank *IBankTransactorSession) Migrate(_a common.Address) (*types.Transaction, error) {
	return _IBank.Contract.Migrate(&_IBank.TransactOpts, _a)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address _a, uint256 _m) payable returns()
func (_IBank *IBankTransactor) Mint(opts *bind.TransactOpts, _a common.Address, _m *big.Int) (*types.Transaction, error) {
	return _IBank.contract.Transact(opts, "mint", _a, _m)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address _a, uint256 _m) payable returns()
func (_IBank *IBankSession) Mint(_a common.Address, _m *big.Int) (*types.Transaction, error) {
	return _IBank.Contract.Mint(&_IBank.TransactOpts, _a, _m)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address _a, uint256 _m) payable returns()
func (_IBank *IBankTransactorSession) Mint(_a common.Address, _m *big.Int) (*types.Transaction, error) {
	return _IBank.Contract.Mint(&_IBank.TransactOpts, _a, _m)
}

// Set is a paid mutator transaction binding the contract method 0xa815ff15.
//
// Solidity: function set(string _s, address _a) returns()
func (_IBank *IBankTransactor) Set(opts *bind.TransactOpts, _s string, _a common.Address) (*types.Transaction, error) {
	return _IBank.contract.Transact(opts, "set", _s, _a)
}

// Set is a paid mutator transaction binding the contract method 0xa815ff15.
//
// Solidity: function set(string _s, address _a) returns()
func (_IBank *IBankSession) Set(_s string, _a common.Address) (*types.Transaction, error) {
	return _IBank.Contract.Set(&_IBank.TransactOpts, _s, _a)
}

// Set is a paid mutator transaction binding the contract method 0xa815ff15.
//
// Solidity: function set(string _s, address _a) returns()
func (_IBank *IBankTransactorSession) Set(_s string, _a common.Address) (*types.Transaction, error) {
	return _IBank.Contract.Set(&_IBank.TransactOpts, _s, _a)
}

// TransferIn is a paid mutator transaction binding the contract method 0xe8888915.
//
// Solidity: function transferIn(address _a, uint256 _m) payable returns()
func (_IBank *IBankTransactor) TransferIn(opts *bind.TransactOpts, _a common.Address, _m *big.Int) (*types.Transaction, error) {
	return _IBank.contract.Transact(opts, "transferIn", _a, _m)
}

// TransferIn is a paid mutator transaction binding the contract method 0xe8888915.
//
// Solidity: function transferIn(address _a, uint256 _m) payable returns()
func (_IBank *IBankSession) TransferIn(_a common.Address, _m *big.Int) (*types.Transaction, error) {
	return _IBank.Contract.TransferIn(&_IBank.TransactOpts, _a, _m)
}

// TransferIn is a paid mutator transaction binding the contract method 0xe8888915.
//
// Solidity: function transferIn(address _a, uint256 _m) payable returns()
func (_IBank *IBankTransactorSession) TransferIn(_a common.Address, _m *big.Int) (*types.Transaction, error) {
	return _IBank.Contract.TransferIn(&_IBank.TransactOpts, _a, _m)
}

// TransferOut is a paid mutator transaction binding the contract method 0x76890c58.
//
// Solidity: function transferOut(address _a, uint256 _m) payable returns()
func (_IBank *IBankTransactor) TransferOut(opts *bind.TransactOpts, _a common.Address, _m *big.Int) (*types.Transaction, error) {
	return _IBank.contract.Transact(opts, "transferOut", _a, _m)
}

// TransferOut is a paid mutator transaction binding the contract method 0x76890c58.
//
// Solidity: function transferOut(address _a, uint256 _m) payable returns()
func (_IBank *IBankSession) TransferOut(_a common.Address, _m *big.Int) (*types.Transaction, error) {
	return _IBank.Contract.TransferOut(&_IBank.TransactOpts, _a, _m)
}

// TransferOut is a paid mutator transaction binding the contract method 0x76890c58.
//
// Solidity: function transferOut(address _a, uint256 _m) payable returns()
func (_IBank *IBankTransactorSession) TransferOut(_a common.Address, _m *big.Int) (*types.Transaction, error) {
	return _IBank.Contract.TransferOut(&_IBank.TransactOpts, _a, _m)
}

// IBankMigrateIterator is returned from FilterMigrate and is used to iterate over the raw logs and unpacked data for Migrate events raised by the IBank contract.
type IBankMigrateIterator struct {
	Event *IBankMigrate // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IBankMigrateIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IBankMigrate)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IBankMigrate)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IBankMigrateIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IBankMigrateIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IBankMigrate represents a Migrate event raised by the IBank contract.
type IBankMigrate struct {
	From common.Address
	To   common.Address
	M    *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterMigrate is a free log retrieval operation binding the contract event 0x18df02dcc52b9c494f391df09661519c0069bd8540141946280399408205ca1a.
//
// Solidity: event Migrate(address indexed _from, address _to, uint256 _m)
func (_IBank *IBankFilterer) FilterMigrate(opts *bind.FilterOpts, _from []common.Address) (*IBankMigrateIterator, error) {

	var _fromRule []interface{}
	for _, _fromItem := range _from {
		_fromRule = append(_fromRule, _fromItem)
	}

	logs, sub, err := _IBank.contract.FilterLogs(opts, "Migrate", _fromRule)
	if err != nil {
		return nil, err
	}
	return &IBankMigrateIterator{contract: _IBank.contract, event: "Migrate", logs: logs, sub: sub}, nil
}

// WatchMigrate is a free log subscription operation binding the contract event 0x18df02dcc52b9c494f391df09661519c0069bd8540141946280399408205ca1a.
//
// Solidity: event Migrate(address indexed _from, address _to, uint256 _m)
func (_IBank *IBankFilterer) WatchMigrate(opts *bind.WatchOpts, sink chan<- *IBankMigrate, _from []common.Address) (event.Subscription, error) {

	var _fromRule []interface{}
	for _, _fromItem := range _from {
		_fromRule = append(_fromRule, _fromItem)
	}

	logs, sub, err := _IBank.contract.WatchLogs(opts, "Migrate", _fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IBankMigrate)
				if err := _IBank.contract.UnpackLog(event, "Migrate", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMigrate is a log parse operation binding the contract event 0x18df02dcc52b9c494f391df09661519c0069bd8540141946280399408205ca1a.
//
// Solidity: event Migrate(address indexed _from, address _to, uint256 _m)
func (_IBank *IBankFilterer) ParseMigrate(log types.Log) (*IBankMigrate, error) {
	event := new(IBankMigrate)
	if err := _IBank.contract.UnpackLog(event, "Migrate", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IBankMintIterator is returned from FilterMint and is used to iterate over the raw logs and unpacked data for Mint events raised by the IBank contract.
type IBankMintIterator struct {
	Event *IBankMint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IBankMintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IBankMint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IBankMint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IBankMintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IBankMintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IBankMint represents a Mint event raised by the IBank contract.
type IBankMint struct {
	To  common.Address
	M   *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterMint is a free log retrieval operation binding the contract event 0x0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885.
//
// Solidity: event Mint(address indexed _to, uint256 _m)
func (_IBank *IBankFilterer) FilterMint(opts *bind.FilterOpts, _to []common.Address) (*IBankMintIterator, error) {

	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _IBank.contract.FilterLogs(opts, "Mint", _toRule)
	if err != nil {
		return nil, err
	}
	return &IBankMintIterator{contract: _IBank.contract, event: "Mint", logs: logs, sub: sub}, nil
}

// WatchMint is a free log subscription operation binding the contract event 0x0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885.
//
// Solidity: event Mint(address indexed _to, uint256 _m)
func (_IBank *IBankFilterer) WatchMint(opts *bind.WatchOpts, sink chan<- *IBankMint, _to []common.Address) (event.Subscription, error) {

	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _IBank.contract.WatchLogs(opts, "Mint", _toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IBankMint)
				if err := _IBank.contract.UnpackLog(event, "Mint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMint is a log parse operation binding the contract event 0x0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885.
//
// Solidity: event Mint(address indexed _to, uint256 _m)
func (_IBank *IBankFilterer) ParseMint(log types.Log) (*IBankMint, error) {
	event := new(IBankMint)
	if err := _IBank.contract.UnpackLog(event, "Mint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IBankSetIterator is returned from FilterSet and is used to iterate over the raw logs and unpacked data for Set events raised by the IBank contract.
type IBankSetIterator struct {
	Event *IBankSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IBankSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IBankSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IBankSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IBankSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IBankSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IBankSet represents a Set event raised by the IBank contract.
type IBankSet struct {
	S   common.Hash
	To  common.Address
	Raw types.Log // Blockchain specific contextual infos
}

// FilterSet is a free log retrieval operation binding the contract event 0x496595ced95720268cf8bc60bae3f35024ff2a130f73ac4e20f5c1eaca35db99.
//
// Solidity: event Set(string indexed _s, address _to)
func (_IBank *IBankFilterer) FilterSet(opts *bind.FilterOpts, _s []string) (*IBankSetIterator, error) {

	var _sRule []interface{}
	for _, _sItem := range _s {
		_sRule = append(_sRule, _sItem)
	}

	logs, sub, err := _IBank.contract.FilterLogs(opts, "Set", _sRule)
	if err != nil {
		return nil, err
	}
	return &IBankSetIterator{contract: _IBank.contract, event: "Set", logs: logs, sub: sub}, nil
}

// WatchSet is a free log subscription operation binding the contract event 0x496595ced95720268cf8bc60bae3f35024ff2a130f73ac4e20f5c1eaca35db99.
//
// Solidity: event Set(string indexed _s, address _to)
func (_IBank *IBankFilterer) WatchSet(opts *bind.WatchOpts, sink chan<- *IBankSet, _s []string) (event.Subscription, error) {

	var _sRule []interface{}
	for _, _sItem := range _s {
		_sRule = append(_sRule, _sItem)
	}

	logs, sub, err := _IBank.contract.WatchLogs(opts, "Set", _sRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IBankSet)
				if err := _IBank.contract.UnpackLog(event, "Set", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSet is a log parse operation binding the contract event 0x496595ced95720268cf8bc60bae3f35024ff2a130f73ac4e20f5c1eaca35db99.
//
// Solidity: event Set(string indexed _s, address _to)
func (_IBank *IBankFilterer) ParseSet(log types.Log) (*IBankSet, error) {
	event := new(IBankSet)
	if err := _IBank.contract.UnpackLog(event, "Set", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IBankTransferInIterator is returned from FilterTransferIn and is used to iterate over the raw logs and unpacked data for TransferIn events raised by the IBank contract.
type IBankTransferInIterator struct {
	Event *IBankTransferIn // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IBankTransferInIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IBankTransferIn)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IBankTransferIn)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IBankTransferInIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IBankTransferInIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IBankTransferIn represents a TransferIn event raised by the IBank contract.
type IBankTransferIn struct {
	Caller common.Address
	From   common.Address
	M      *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterTransferIn is a free log retrieval operation binding the contract event 0x8ab008cb8444c6d8f2fa3dc0b159b5a86c62b00092219a6c69757805cbf7bde7.
//
// Solidity: event TransferIn(address indexed _caller, address _from, uint256 _m)
func (_IBank *IBankFilterer) FilterTransferIn(opts *bind.FilterOpts, _caller []common.Address) (*IBankTransferInIterator, error) {

	var _callerRule []interface{}
	for _, _callerItem := range _caller {
		_callerRule = append(_callerRule, _callerItem)
	}

	logs, sub, err := _IBank.contract.FilterLogs(opts, "TransferIn", _callerRule)
	if err != nil {
		return nil, err
	}
	return &IBankTransferInIterator{contract: _IBank.contract, event: "TransferIn", logs: logs, sub: sub}, nil
}

// WatchTransferIn is a free log subscription operation binding the contract event 0x8ab008cb8444c6d8f2fa3dc0b159b5a86c62b00092219a6c69757805cbf7bde7.
//
// Solidity: event TransferIn(address indexed _caller, address _from, uint256 _m)
func (_IBank *IBankFilterer) WatchTransferIn(opts *bind.WatchOpts, sink chan<- *IBankTransferIn, _caller []common.Address) (event.Subscription, error) {

	var _callerRule []interface{}
	for _, _callerItem := range _caller {
		_callerRule = append(_callerRule, _callerItem)
	}

	logs, sub, err := _IBank.contract.WatchLogs(opts, "TransferIn", _callerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IBankTransferIn)
				if err := _IBank.contract.UnpackLog(event, "TransferIn", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransferIn is a log parse operation binding the contract event 0x8ab008cb8444c6d8f2fa3dc0b159b5a86c62b00092219a6c69757805cbf7bde7.
//
// Solidity: event TransferIn(address indexed _caller, address _from, uint256 _m)
func (_IBank *IBankFilterer) ParseTransferIn(log types.Log) (*IBankTransferIn, error) {
	event := new(IBankTransferIn)
	if err := _IBank.contract.UnpackLog(event, "TransferIn", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IBankTransferOutIterator is returned from FilterTransferOut and is used to iterate over the raw logs and unpacked data for TransferOut events raised by the IBank contract.
type IBankTransferOutIterator struct {
	Event *IBankTransferOut // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IBankTransferOutIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IBankTransferOut)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IBankTransferOut)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IBankTransferOutIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IBankTransferOutIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IBankTransferOut represents a TransferOut event raised by the IBank contract.
type IBankTransferOut struct {
	Caller common.Address
	To     common.Address
	M      *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterTransferOut is a free log retrieval operation binding the contract event 0x5d2c285d7e86ec84b7a404ba6d7627ca0a71709acce9c1cc05fada583e3ded81.
//
// Solidity: event TransferOut(address indexed _caller, address _to, uint256 _m)
func (_IBank *IBankFilterer) FilterTransferOut(opts *bind.FilterOpts, _caller []common.Address) (*IBankTransferOutIterator, error) {

	var _callerRule []interface{}
	for _, _callerItem := range _caller {
		_callerRule = append(_callerRule, _callerItem)
	}

	logs, sub, err := _IBank.contract.FilterLogs(opts, "TransferOut", _callerRule)
	if err != nil {
		return nil, err
	}
	return &IBankTransferOutIterator{contract: _IBank.contract, event: "TransferOut", logs: logs, sub: sub}, nil
}

// WatchTransferOut is a free log subscription operation binding the contract event 0x5d2c285d7e86ec84b7a404ba6d7627ca0a71709acce9c1cc05fada583e3ded81.
//
// Solidity: event TransferOut(address indexed _caller, address _to, uint256 _m)
func (_IBank *IBankFilterer) WatchTransferOut(opts *bind.WatchOpts, sink chan<- *IBankTransferOut, _caller []common.Address) (event.Subscription, error) {

	var _callerRule []interface{}
	for _, _callerItem := range _caller {
		_callerRule = append(_callerRule, _callerItem)
	}

	logs, sub, err := _IBank.contract.WatchLogs(opts, "TransferOut", _callerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IBankTransferOut)
				if err := _IBank.contract.UnpackLog(event, "TransferOut", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransferOut is a log parse operation binding the contract event 0x5d2c285d7e86ec84b7a404ba6d7627ca0a71709acce9c1cc05fada583e3ded81.
//
// Solidity: event TransferOut(address indexed _caller, address _to, uint256 _m)
func (_IBank *IBankFilterer) ParseTransferOut(log types.Log) (*IBankTransferOut, error) {
	event := new(IBankTransferOut)
	if err := _IBank.contract.UnpackLog(event, "TransferOut", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IControlABI is the input ABI used to generate the binding from.
const IControlABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_m\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_typ\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_m\",\"type\":\"uint256\"}],\"name\":\"Punish\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_m\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_typ\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_m\",\"type\":\"uint256\"}],\"name\":\"punish\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IControlFuncSigs maps the 4-byte function signature to its string representation.
var IControlFuncSigs = map[string]string{
	"40c10f19": "mint(address,uint256)",
	"06f0b4f1": "punish(address,uint8,address,uint256)",
}

// IControl is an auto generated Go binding around an Ethereum contract.
type IControl struct {
	IControlCaller     // Read-only binding to the contract
	IControlTransactor // Write-only binding to the contract
	IControlFilterer   // Log filterer for contract events
}

// IControlCaller is an auto generated read-only Go binding around an Ethereum contract.
type IControlCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IControlTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IControlTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IControlFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IControlFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IControlSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IControlSession struct {
	Contract     *IControl         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IControlCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IControlCallerSession struct {
	Contract *IControlCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// IControlTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IControlTransactorSession struct {
	Contract     *IControlTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// IControlRaw is an auto generated low-level Go binding around an Ethereum contract.
type IControlRaw struct {
	Contract *IControl // Generic contract binding to access the raw methods on
}

// IControlCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IControlCallerRaw struct {
	Contract *IControlCaller // Generic read-only contract binding to access the raw methods on
}

// IControlTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IControlTransactorRaw struct {
	Contract *IControlTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIControl creates a new instance of IControl, bound to a specific deployed contract.
func NewIControl(address common.Address, backend bind.ContractBackend) (*IControl, error) {
	contract, err := bindIControl(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IControl{IControlCaller: IControlCaller{contract: contract}, IControlTransactor: IControlTransactor{contract: contract}, IControlFilterer: IControlFilterer{contract: contract}}, nil
}

// NewIControlCaller creates a new read-only instance of IControl, bound to a specific deployed contract.
func NewIControlCaller(address common.Address, caller bind.ContractCaller) (*IControlCaller, error) {
	contract, err := bindIControl(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IControlCaller{contract: contract}, nil
}

// NewIControlTransactor creates a new write-only instance of IControl, bound to a specific deployed contract.
func NewIControlTransactor(address common.Address, transactor bind.ContractTransactor) (*IControlTransactor, error) {
	contract, err := bindIControl(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IControlTransactor{contract: contract}, nil
}

// NewIControlFilterer creates a new log filterer instance of IControl, bound to a specific deployed contract.
func NewIControlFilterer(address common.Address, filterer bind.ContractFilterer) (*IControlFilterer, error) {
	contract, err := bindIControl(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IControlFilterer{contract: contract}, nil
}

// bindIControl binds a generic wrapper to an already deployed contract.
func bindIControl(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IControlABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IControl *IControlRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IControl.Contract.IControlCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IControl *IControlRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IControl.Contract.IControlTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IControl *IControlRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IControl.Contract.IControlTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IControl *IControlCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IControl.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IControl *IControlTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IControl.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IControl *IControlTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IControl.Contract.contract.Transact(opts, method, params...)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address _a, uint256 _m) returns()
func (_IControl *IControlTransactor) Mint(opts *bind.TransactOpts, _a common.Address, _m *big.Int) (*types.Transaction, error) {
	return _IControl.contract.Transact(opts, "mint", _a, _m)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address _a, uint256 _m) returns()
func (_IControl *IControlSession) Mint(_a common.Address, _m *big.Int) (*types.Transaction, error) {
	return _IControl.Contract.Mint(&_IControl.TransactOpts, _a, _m)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address _a, uint256 _m) returns()
func (_IControl *IControlTransactorSession) Mint(_a common.Address, _m *big.Int) (*types.Transaction, error) {
	return _IControl.Contract.Mint(&_IControl.TransactOpts, _a, _m)
}

// Punish is a paid mutator transaction binding the contract method 0x06f0b4f1.
//
// Solidity: function punish(address _a, uint8 _typ, address _to, uint256 _m) returns()
func (_IControl *IControlTransactor) Punish(opts *bind.TransactOpts, _a common.Address, _typ uint8, _to common.Address, _m *big.Int) (*types.Transaction, error) {
	return _IControl.contract.Transact(opts, "punish", _a, _typ, _to, _m)
}

// Punish is a paid mutator transaction binding the contract method 0x06f0b4f1.
//
// Solidity: function punish(address _a, uint8 _typ, address _to, uint256 _m) returns()
func (_IControl *IControlSession) Punish(_a common.Address, _typ uint8, _to common.Address, _m *big.Int) (*types.Transaction, error) {
	return _IControl.Contract.Punish(&_IControl.TransactOpts, _a, _typ, _to, _m)
}

// Punish is a paid mutator transaction binding the contract method 0x06f0b4f1.
//
// Solidity: function punish(address _a, uint8 _typ, address _to, uint256 _m) returns()
func (_IControl *IControlTransactorSession) Punish(_a common.Address, _typ uint8, _to common.Address, _m *big.Int) (*types.Transaction, error) {
	return _IControl.Contract.Punish(&_IControl.TransactOpts, _a, _typ, _to, _m)
}

// IControlMintIterator is returned from FilterMint and is used to iterate over the raw logs and unpacked data for Mint events raised by the IControl contract.
type IControlMintIterator struct {
	Event *IControlMint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IControlMintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IControlMint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IControlMint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IControlMintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IControlMintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IControlMint represents a Mint event raised by the IControl contract.
type IControlMint struct {
	A   common.Address
	M   *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterMint is a free log retrieval operation binding the contract event 0x0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885.
//
// Solidity: event Mint(address indexed _a, uint256 _m)
func (_IControl *IControlFilterer) FilterMint(opts *bind.FilterOpts, _a []common.Address) (*IControlMintIterator, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _IControl.contract.FilterLogs(opts, "Mint", _aRule)
	if err != nil {
		return nil, err
	}
	return &IControlMintIterator{contract: _IControl.contract, event: "Mint", logs: logs, sub: sub}, nil
}

// WatchMint is a free log subscription operation binding the contract event 0x0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885.
//
// Solidity: event Mint(address indexed _a, uint256 _m)
func (_IControl *IControlFilterer) WatchMint(opts *bind.WatchOpts, sink chan<- *IControlMint, _a []common.Address) (event.Subscription, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _IControl.contract.WatchLogs(opts, "Mint", _aRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IControlMint)
				if err := _IControl.contract.UnpackLog(event, "Mint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMint is a log parse operation binding the contract event 0x0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885.
//
// Solidity: event Mint(address indexed _a, uint256 _m)
func (_IControl *IControlFilterer) ParseMint(log types.Log) (*IControlMint, error) {
	event := new(IControlMint)
	if err := _IControl.contract.UnpackLog(event, "Mint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IControlPunishIterator is returned from FilterPunish and is used to iterate over the raw logs and unpacked data for Punish events raised by the IControl contract.
type IControlPunishIterator struct {
	Event *IControlPunish // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IControlPunishIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IControlPunish)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IControlPunish)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IControlPunishIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IControlPunishIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IControlPunish represents a Punish event raised by the IControl contract.
type IControlPunish struct {
	A   common.Address
	Typ uint8
	To  common.Address
	M   *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterPunish is a free log retrieval operation binding the contract event 0xc6ef96923e613455515c6723eff1723445b22427fe442e8bf742e9d29b4b3c32.
//
// Solidity: event Punish(address indexed _a, uint8 _typ, address _to, uint256 _m)
func (_IControl *IControlFilterer) FilterPunish(opts *bind.FilterOpts, _a []common.Address) (*IControlPunishIterator, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _IControl.contract.FilterLogs(opts, "Punish", _aRule)
	if err != nil {
		return nil, err
	}
	return &IControlPunishIterator{contract: _IControl.contract, event: "Punish", logs: logs, sub: sub}, nil
}

// WatchPunish is a free log subscription operation binding the contract event 0xc6ef96923e613455515c6723eff1723445b22427fe442e8bf742e9d29b4b3c32.
//
// Solidity: event Punish(address indexed _a, uint8 _typ, address _to, uint256 _m)
func (_IControl *IControlFilterer) WatchPunish(opts *bind.WatchOpts, sink chan<- *IControlPunish, _a []common.Address) (event.Subscription, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _IControl.contract.WatchLogs(opts, "Punish", _aRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IControlPunish)
				if err := _IControl.contract.UnpackLog(event, "Punish", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePunish is a log parse operation binding the contract event 0xc6ef96923e613455515c6723eff1723445b22427fe442e8bf742e9d29b4b3c32.
//
// Solidity: event Punish(address indexed _a, uint8 _typ, address _to, uint256 _m)
func (_IControl *IControlFilterer) ParsePunish(log types.Log) (*IControlPunish, error) {
	event := new(IControlPunish)
	if err := _IControl.contract.UnpackLog(event, "Punish", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IEpochABI is the input ABI used to generate the binding from.
const IEpochABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_e\",\"type\":\"uint64\"}],\"name\":\"SetEpoch\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"check\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"current\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_epoch\",\"type\":\"uint64\"}],\"name\":\"getEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IEpochFuncSigs maps the 4-byte function signature to its string representation.
var IEpochFuncSigs = map[string]string{
	"919840ad": "check()",
	"9fa6a6e3": "current()",
	"12a02c82": "getEpoch(uint64)",
}

// IEpoch is an auto generated Go binding around an Ethereum contract.
type IEpoch struct {
	IEpochCaller     // Read-only binding to the contract
	IEpochTransactor // Write-only binding to the contract
	IEpochFilterer   // Log filterer for contract events
}

// IEpochCaller is an auto generated read-only Go binding around an Ethereum contract.
type IEpochCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IEpochTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IEpochTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IEpochFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IEpochFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IEpochSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IEpochSession struct {
	Contract     *IEpoch           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IEpochCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IEpochCallerSession struct {
	Contract *IEpochCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// IEpochTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IEpochTransactorSession struct {
	Contract     *IEpochTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IEpochRaw is an auto generated low-level Go binding around an Ethereum contract.
type IEpochRaw struct {
	Contract *IEpoch // Generic contract binding to access the raw methods on
}

// IEpochCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IEpochCallerRaw struct {
	Contract *IEpochCaller // Generic read-only contract binding to access the raw methods on
}

// IEpochTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IEpochTransactorRaw struct {
	Contract *IEpochTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIEpoch creates a new instance of IEpoch, bound to a specific deployed contract.
func NewIEpoch(address common.Address, backend bind.ContractBackend) (*IEpoch, error) {
	contract, err := bindIEpoch(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IEpoch{IEpochCaller: IEpochCaller{contract: contract}, IEpochTransactor: IEpochTransactor{contract: contract}, IEpochFilterer: IEpochFilterer{contract: contract}}, nil
}

// NewIEpochCaller creates a new read-only instance of IEpoch, bound to a specific deployed contract.
func NewIEpochCaller(address common.Address, caller bind.ContractCaller) (*IEpochCaller, error) {
	contract, err := bindIEpoch(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IEpochCaller{contract: contract}, nil
}

// NewIEpochTransactor creates a new write-only instance of IEpoch, bound to a specific deployed contract.
func NewIEpochTransactor(address common.Address, transactor bind.ContractTransactor) (*IEpochTransactor, error) {
	contract, err := bindIEpoch(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IEpochTransactor{contract: contract}, nil
}

// NewIEpochFilterer creates a new log filterer instance of IEpoch, bound to a specific deployed contract.
func NewIEpochFilterer(address common.Address, filterer bind.ContractFilterer) (*IEpochFilterer, error) {
	contract, err := bindIEpoch(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IEpochFilterer{contract: contract}, nil
}

// bindIEpoch binds a generic wrapper to an already deployed contract.
func bindIEpoch(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IEpochABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IEpoch *IEpochRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IEpoch.Contract.IEpochCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IEpoch *IEpochRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IEpoch.Contract.IEpochTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IEpoch *IEpochRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IEpoch.Contract.IEpochTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IEpoch *IEpochCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IEpoch.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IEpoch *IEpochTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IEpoch.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IEpoch *IEpochTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IEpoch.Contract.contract.Transact(opts, method, params...)
}

// Check is a paid mutator transaction binding the contract method 0x919840ad.
//
// Solidity: function check() returns()
func (_IEpoch *IEpochTransactor) Check(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IEpoch.contract.Transact(opts, "check")
}

// Check is a paid mutator transaction binding the contract method 0x919840ad.
//
// Solidity: function check() returns()
func (_IEpoch *IEpochSession) Check() (*types.Transaction, error) {
	return _IEpoch.Contract.Check(&_IEpoch.TransactOpts)
}

// Check is a paid mutator transaction binding the contract method 0x919840ad.
//
// Solidity: function check() returns()
func (_IEpoch *IEpochTransactorSession) Check() (*types.Transaction, error) {
	return _IEpoch.Contract.Check(&_IEpoch.TransactOpts)
}

// Current is a paid mutator transaction binding the contract method 0x9fa6a6e3.
//
// Solidity: function current() returns(uint64)
func (_IEpoch *IEpochTransactor) Current(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IEpoch.contract.Transact(opts, "current")
}

// Current is a paid mutator transaction binding the contract method 0x9fa6a6e3.
//
// Solidity: function current() returns(uint64)
func (_IEpoch *IEpochSession) Current() (*types.Transaction, error) {
	return _IEpoch.Contract.Current(&_IEpoch.TransactOpts)
}

// Current is a paid mutator transaction binding the contract method 0x9fa6a6e3.
//
// Solidity: function current() returns(uint64)
func (_IEpoch *IEpochTransactorSession) Current() (*types.Transaction, error) {
	return _IEpoch.Contract.Current(&_IEpoch.TransactOpts)
}

// GetEpoch is a paid mutator transaction binding the contract method 0x12a02c82.
//
// Solidity: function getEpoch(uint64 _epoch) returns(uint256, bytes32)
func (_IEpoch *IEpochTransactor) GetEpoch(opts *bind.TransactOpts, _epoch uint64) (*types.Transaction, error) {
	return _IEpoch.contract.Transact(opts, "getEpoch", _epoch)
}

// GetEpoch is a paid mutator transaction binding the contract method 0x12a02c82.
//
// Solidity: function getEpoch(uint64 _epoch) returns(uint256, bytes32)
func (_IEpoch *IEpochSession) GetEpoch(_epoch uint64) (*types.Transaction, error) {
	return _IEpoch.Contract.GetEpoch(&_IEpoch.TransactOpts, _epoch)
}

// GetEpoch is a paid mutator transaction binding the contract method 0x12a02c82.
//
// Solidity: function getEpoch(uint64 _epoch) returns(uint256, bytes32)
func (_IEpoch *IEpochTransactorSession) GetEpoch(_epoch uint64) (*types.Transaction, error) {
	return _IEpoch.Contract.GetEpoch(&_IEpoch.TransactOpts, _epoch)
}

// IEpochSetEpochIterator is returned from FilterSetEpoch and is used to iterate over the raw logs and unpacked data for SetEpoch events raised by the IEpoch contract.
type IEpochSetEpochIterator struct {
	Event *IEpochSetEpoch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IEpochSetEpochIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IEpochSetEpoch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IEpochSetEpoch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IEpochSetEpochIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IEpochSetEpochIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IEpochSetEpoch represents a SetEpoch event raised by the IEpoch contract.
type IEpochSetEpoch struct {
	E   uint64
	Raw types.Log // Blockchain specific contextual infos
}

// FilterSetEpoch is a free log retrieval operation binding the contract event 0x9d4ccb161ea809df14334516cc3070025c80baddb8e8364afaca6a6fe31bfd75.
//
// Solidity: event SetEpoch(uint64 _e)
func (_IEpoch *IEpochFilterer) FilterSetEpoch(opts *bind.FilterOpts) (*IEpochSetEpochIterator, error) {

	logs, sub, err := _IEpoch.contract.FilterLogs(opts, "SetEpoch")
	if err != nil {
		return nil, err
	}
	return &IEpochSetEpochIterator{contract: _IEpoch.contract, event: "SetEpoch", logs: logs, sub: sub}, nil
}

// WatchSetEpoch is a free log subscription operation binding the contract event 0x9d4ccb161ea809df14334516cc3070025c80baddb8e8364afaca6a6fe31bfd75.
//
// Solidity: event SetEpoch(uint64 _e)
func (_IEpoch *IEpochFilterer) WatchSetEpoch(opts *bind.WatchOpts, sink chan<- *IEpochSetEpoch) (event.Subscription, error) {

	logs, sub, err := _IEpoch.contract.WatchLogs(opts, "SetEpoch")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IEpochSetEpoch)
				if err := _IEpoch.contract.UnpackLog(event, "SetEpoch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSetEpoch is a log parse operation binding the contract event 0x9d4ccb161ea809df14334516cc3070025c80baddb8e8364afaca6a6fe31bfd75.
//
// Solidity: event SetEpoch(uint64 _e)
func (_IEpoch *IEpochFilterer) ParseSetEpoch(log types.Log) (*IEpochSetEpoch, error) {
	event := new(IEpochSetEpoch)
	if err := _IEpoch.contract.UnpackLog(event, "SetEpoch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IFileABI is the input ABI used to generate the binding from.
const IFileABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_fi\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_fn\",\"type\":\"string\"}],\"name\":\"AddFile\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_fi\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_pi\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_piece\",\"type\":\"bytes\"}],\"name\":\"AddPiece\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_fi\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_pi\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_ri\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_rn\",\"type\":\"bytes\"}],\"name\":\"AddReplica\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_e\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_m\",\"type\":\"uint256\"}],\"name\":\"Settle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_m\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_r\",\"type\":\"bytes\"}],\"name\":\"getRExpire\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_ri\",\"type\":\"uint64\"}],\"name\":\"getSReplica\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_e\",\"type\":\"uint64\"}],\"name\":\"getStoreAt\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IFileFuncSigs maps the 4-byte function signature to its string representation.
var IFileFuncSigs = map[string]string{
	"accbe33b": "getRExpire(bytes)",
	"6f3e37b1": "getSReplica(address,uint64)",
	"6150ad81": "getStoreAt(address,uint64)",
}

// IFile is an auto generated Go binding around an Ethereum contract.
type IFile struct {
	IFileCaller     // Read-only binding to the contract
	IFileTransactor // Write-only binding to the contract
	IFileFilterer   // Log filterer for contract events
}

// IFileCaller is an auto generated read-only Go binding around an Ethereum contract.
type IFileCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IFileTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IFileTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IFileFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IFileFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IFileSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IFileSession struct {
	Contract     *IFile            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IFileCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IFileCallerSession struct {
	Contract *IFileCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// IFileTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IFileTransactorSession struct {
	Contract     *IFileTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IFileRaw is an auto generated low-level Go binding around an Ethereum contract.
type IFileRaw struct {
	Contract *IFile // Generic contract binding to access the raw methods on
}

// IFileCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IFileCallerRaw struct {
	Contract *IFileCaller // Generic read-only contract binding to access the raw methods on
}

// IFileTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IFileTransactorRaw struct {
	Contract *IFileTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIFile creates a new instance of IFile, bound to a specific deployed contract.
func NewIFile(address common.Address, backend bind.ContractBackend) (*IFile, error) {
	contract, err := bindIFile(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IFile{IFileCaller: IFileCaller{contract: contract}, IFileTransactor: IFileTransactor{contract: contract}, IFileFilterer: IFileFilterer{contract: contract}}, nil
}

// NewIFileCaller creates a new read-only instance of IFile, bound to a specific deployed contract.
func NewIFileCaller(address common.Address, caller bind.ContractCaller) (*IFileCaller, error) {
	contract, err := bindIFile(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IFileCaller{contract: contract}, nil
}

// NewIFileTransactor creates a new write-only instance of IFile, bound to a specific deployed contract.
func NewIFileTransactor(address common.Address, transactor bind.ContractTransactor) (*IFileTransactor, error) {
	contract, err := bindIFile(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IFileTransactor{contract: contract}, nil
}

// NewIFileFilterer creates a new log filterer instance of IFile, bound to a specific deployed contract.
func NewIFileFilterer(address common.Address, filterer bind.ContractFilterer) (*IFileFilterer, error) {
	contract, err := bindIFile(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IFileFilterer{contract: contract}, nil
}

// bindIFile binds a generic wrapper to an already deployed contract.
func bindIFile(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IFileABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IFile *IFileRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IFile.Contract.IFileCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IFile *IFileRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IFile.Contract.IFileTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IFile *IFileRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IFile.Contract.IFileTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IFile *IFileCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IFile.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IFile *IFileTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IFile.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IFile *IFileTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IFile.Contract.contract.Transact(opts, method, params...)
}

// GetRExpire is a free data retrieval call binding the contract method 0xaccbe33b.
//
// Solidity: function getRExpire(bytes _r) view returns(uint64)
func (_IFile *IFileCaller) GetRExpire(opts *bind.CallOpts, _r []byte) (uint64, error) {
	var out []interface{}
	err := _IFile.contract.Call(opts, &out, "getRExpire", _r)

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// GetRExpire is a free data retrieval call binding the contract method 0xaccbe33b.
//
// Solidity: function getRExpire(bytes _r) view returns(uint64)
func (_IFile *IFileSession) GetRExpire(_r []byte) (uint64, error) {
	return _IFile.Contract.GetRExpire(&_IFile.CallOpts, _r)
}

// GetRExpire is a free data retrieval call binding the contract method 0xaccbe33b.
//
// Solidity: function getRExpire(bytes _r) view returns(uint64)
func (_IFile *IFileCallerSession) GetRExpire(_r []byte) (uint64, error) {
	return _IFile.Contract.GetRExpire(&_IFile.CallOpts, _r)
}

// GetSReplica is a paid mutator transaction binding the contract method 0x6f3e37b1.
//
// Solidity: function getSReplica(address _a, uint64 _ri) returns(bytes)
func (_IFile *IFileTransactor) GetSReplica(opts *bind.TransactOpts, _a common.Address, _ri uint64) (*types.Transaction, error) {
	return _IFile.contract.Transact(opts, "getSReplica", _a, _ri)
}

// GetSReplica is a paid mutator transaction binding the contract method 0x6f3e37b1.
//
// Solidity: function getSReplica(address _a, uint64 _ri) returns(bytes)
func (_IFile *IFileSession) GetSReplica(_a common.Address, _ri uint64) (*types.Transaction, error) {
	return _IFile.Contract.GetSReplica(&_IFile.TransactOpts, _a, _ri)
}

// GetSReplica is a paid mutator transaction binding the contract method 0x6f3e37b1.
//
// Solidity: function getSReplica(address _a, uint64 _ri) returns(bytes)
func (_IFile *IFileTransactorSession) GetSReplica(_a common.Address, _ri uint64) (*types.Transaction, error) {
	return _IFile.Contract.GetSReplica(&_IFile.TransactOpts, _a, _ri)
}

// GetStoreAt is a paid mutator transaction binding the contract method 0x6150ad81.
//
// Solidity: function getStoreAt(address _a, uint64 _e) returns(uint64, uint64)
func (_IFile *IFileTransactor) GetStoreAt(opts *bind.TransactOpts, _a common.Address, _e uint64) (*types.Transaction, error) {
	return _IFile.contract.Transact(opts, "getStoreAt", _a, _e)
}

// GetStoreAt is a paid mutator transaction binding the contract method 0x6150ad81.
//
// Solidity: function getStoreAt(address _a, uint64 _e) returns(uint64, uint64)
func (_IFile *IFileSession) GetStoreAt(_a common.Address, _e uint64) (*types.Transaction, error) {
	return _IFile.Contract.GetStoreAt(&_IFile.TransactOpts, _a, _e)
}

// GetStoreAt is a paid mutator transaction binding the contract method 0x6150ad81.
//
// Solidity: function getStoreAt(address _a, uint64 _e) returns(uint64, uint64)
func (_IFile *IFileTransactorSession) GetStoreAt(_a common.Address, _e uint64) (*types.Transaction, error) {
	return _IFile.Contract.GetStoreAt(&_IFile.TransactOpts, _a, _e)
}

// IFileAddFileIterator is returned from FilterAddFile and is used to iterate over the raw logs and unpacked data for AddFile events raised by the IFile contract.
type IFileAddFileIterator struct {
	Event *IFileAddFile // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IFileAddFileIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IFileAddFile)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IFileAddFile)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IFileAddFileIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IFileAddFileIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IFileAddFile represents a AddFile event raised by the IFile contract.
type IFileAddFile struct {
	A   common.Address
	Fi  uint64
	Fn  string
	Raw types.Log // Blockchain specific contextual infos
}

// FilterAddFile is a free log retrieval operation binding the contract event 0x97fbaabf7920b8891ffb1c0610284ba7fc4b47b0f7ba084b2e634d496da89d29.
//
// Solidity: event AddFile(address indexed _a, uint64 _fi, string _fn)
func (_IFile *IFileFilterer) FilterAddFile(opts *bind.FilterOpts, _a []common.Address) (*IFileAddFileIterator, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _IFile.contract.FilterLogs(opts, "AddFile", _aRule)
	if err != nil {
		return nil, err
	}
	return &IFileAddFileIterator{contract: _IFile.contract, event: "AddFile", logs: logs, sub: sub}, nil
}

// WatchAddFile is a free log subscription operation binding the contract event 0x97fbaabf7920b8891ffb1c0610284ba7fc4b47b0f7ba084b2e634d496da89d29.
//
// Solidity: event AddFile(address indexed _a, uint64 _fi, string _fn)
func (_IFile *IFileFilterer) WatchAddFile(opts *bind.WatchOpts, sink chan<- *IFileAddFile, _a []common.Address) (event.Subscription, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _IFile.contract.WatchLogs(opts, "AddFile", _aRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IFileAddFile)
				if err := _IFile.contract.UnpackLog(event, "AddFile", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAddFile is a log parse operation binding the contract event 0x97fbaabf7920b8891ffb1c0610284ba7fc4b47b0f7ba084b2e634d496da89d29.
//
// Solidity: event AddFile(address indexed _a, uint64 _fi, string _fn)
func (_IFile *IFileFilterer) ParseAddFile(log types.Log) (*IFileAddFile, error) {
	event := new(IFileAddFile)
	if err := _IFile.contract.UnpackLog(event, "AddFile", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IFileAddPieceIterator is returned from FilterAddPiece and is used to iterate over the raw logs and unpacked data for AddPiece events raised by the IFile contract.
type IFileAddPieceIterator struct {
	Event *IFileAddPiece // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IFileAddPieceIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IFileAddPiece)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IFileAddPiece)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IFileAddPieceIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IFileAddPieceIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IFileAddPiece represents a AddPiece event raised by the IFile contract.
type IFileAddPiece struct {
	Fi    uint64
	Pi    uint64
	Piece []byte
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterAddPiece is a free log retrieval operation binding the contract event 0xb121db726a172f87e0af2ba7bf7351c89c3d578b2b329f421b823e7f159f453a.
//
// Solidity: event AddPiece(uint64 _fi, uint64 _pi, bytes _piece)
func (_IFile *IFileFilterer) FilterAddPiece(opts *bind.FilterOpts) (*IFileAddPieceIterator, error) {

	logs, sub, err := _IFile.contract.FilterLogs(opts, "AddPiece")
	if err != nil {
		return nil, err
	}
	return &IFileAddPieceIterator{contract: _IFile.contract, event: "AddPiece", logs: logs, sub: sub}, nil
}

// WatchAddPiece is a free log subscription operation binding the contract event 0xb121db726a172f87e0af2ba7bf7351c89c3d578b2b329f421b823e7f159f453a.
//
// Solidity: event AddPiece(uint64 _fi, uint64 _pi, bytes _piece)
func (_IFile *IFileFilterer) WatchAddPiece(opts *bind.WatchOpts, sink chan<- *IFileAddPiece) (event.Subscription, error) {

	logs, sub, err := _IFile.contract.WatchLogs(opts, "AddPiece")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IFileAddPiece)
				if err := _IFile.contract.UnpackLog(event, "AddPiece", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAddPiece is a log parse operation binding the contract event 0xb121db726a172f87e0af2ba7bf7351c89c3d578b2b329f421b823e7f159f453a.
//
// Solidity: event AddPiece(uint64 _fi, uint64 _pi, bytes _piece)
func (_IFile *IFileFilterer) ParseAddPiece(log types.Log) (*IFileAddPiece, error) {
	event := new(IFileAddPiece)
	if err := _IFile.contract.UnpackLog(event, "AddPiece", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IFileAddReplicaIterator is returned from FilterAddReplica and is used to iterate over the raw logs and unpacked data for AddReplica events raised by the IFile contract.
type IFileAddReplicaIterator struct {
	Event *IFileAddReplica // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IFileAddReplicaIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IFileAddReplica)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IFileAddReplica)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IFileAddReplicaIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IFileAddReplicaIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IFileAddReplica represents a AddReplica event raised by the IFile contract.
type IFileAddReplica struct {
	A   common.Address
	Fi  uint64
	Pi  uint64
	Ri  uint64
	Rn  []byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterAddReplica is a free log retrieval operation binding the contract event 0x9ad879f74989d3436fd7b3ab155a0d4af6ae45b6f98d91513e1398e0bc3afa15.
//
// Solidity: event AddReplica(address indexed _a, uint64 _fi, uint64 _pi, uint64 _ri, bytes _rn)
func (_IFile *IFileFilterer) FilterAddReplica(opts *bind.FilterOpts, _a []common.Address) (*IFileAddReplicaIterator, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _IFile.contract.FilterLogs(opts, "AddReplica", _aRule)
	if err != nil {
		return nil, err
	}
	return &IFileAddReplicaIterator{contract: _IFile.contract, event: "AddReplica", logs: logs, sub: sub}, nil
}

// WatchAddReplica is a free log subscription operation binding the contract event 0x9ad879f74989d3436fd7b3ab155a0d4af6ae45b6f98d91513e1398e0bc3afa15.
//
// Solidity: event AddReplica(address indexed _a, uint64 _fi, uint64 _pi, uint64 _ri, bytes _rn)
func (_IFile *IFileFilterer) WatchAddReplica(opts *bind.WatchOpts, sink chan<- *IFileAddReplica, _a []common.Address) (event.Subscription, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _IFile.contract.WatchLogs(opts, "AddReplica", _aRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IFileAddReplica)
				if err := _IFile.contract.UnpackLog(event, "AddReplica", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAddReplica is a log parse operation binding the contract event 0x9ad879f74989d3436fd7b3ab155a0d4af6ae45b6f98d91513e1398e0bc3afa15.
//
// Solidity: event AddReplica(address indexed _a, uint64 _fi, uint64 _pi, uint64 _ri, bytes _rn)
func (_IFile *IFileFilterer) ParseAddReplica(log types.Log) (*IFileAddReplica, error) {
	event := new(IFileAddReplica)
	if err := _IFile.contract.UnpackLog(event, "AddReplica", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IFileSettleIterator is returned from FilterSettle and is used to iterate over the raw logs and unpacked data for Settle events raised by the IFile contract.
type IFileSettleIterator struct {
	Event *IFileSettle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IFileSettleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IFileSettle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IFileSettle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IFileSettleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IFileSettleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IFileSettle represents a Settle event raised by the IFile contract.
type IFileSettle struct {
	A   common.Address
	E   uint64
	M   *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterSettle is a free log retrieval operation binding the contract event 0x22b9b452d488700bdfeab2aa62972ac1fce3160583db89ab4c799708bf5a2c6c.
//
// Solidity: event Settle(address indexed _a, uint64 _e, uint256 _m)
func (_IFile *IFileFilterer) FilterSettle(opts *bind.FilterOpts, _a []common.Address) (*IFileSettleIterator, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _IFile.contract.FilterLogs(opts, "Settle", _aRule)
	if err != nil {
		return nil, err
	}
	return &IFileSettleIterator{contract: _IFile.contract, event: "Settle", logs: logs, sub: sub}, nil
}

// WatchSettle is a free log subscription operation binding the contract event 0x22b9b452d488700bdfeab2aa62972ac1fce3160583db89ab4c799708bf5a2c6c.
//
// Solidity: event Settle(address indexed _a, uint64 _e, uint256 _m)
func (_IFile *IFileFilterer) WatchSettle(opts *bind.WatchOpts, sink chan<- *IFileSettle, _a []common.Address) (event.Subscription, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _IFile.contract.WatchLogs(opts, "Settle", _aRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IFileSettle)
				if err := _IFile.contract.UnpackLog(event, "Settle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSettle is a log parse operation binding the contract event 0x22b9b452d488700bdfeab2aa62972ac1fce3160583db89ab4c799708bf5a2c6c.
//
// Solidity: event Settle(address indexed _a, uint64 _e, uint256 _m)
func (_IFile *IFileFilterer) ParseSettle(log types.Log) (*IFileSettle, error) {
	event := new(IFileSettle)
	if err := _IFile.contract.UnpackLog(event, "Settle", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IFileWithdrawIterator is returned from FilterWithdraw and is used to iterate over the raw logs and unpacked data for Withdraw events raised by the IFile contract.
type IFileWithdrawIterator struct {
	Event *IFileWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IFileWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IFileWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IFileWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IFileWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IFileWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IFileWithdraw represents a Withdraw event raised by the IFile contract.
type IFileWithdraw struct {
	A   common.Address
	M   *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterWithdraw is a free log retrieval operation binding the contract event 0x884edad9ce6fa2440d8a54cc123490eb96d2768479d49ff9c7366125a9424364.
//
// Solidity: event Withdraw(address indexed _a, uint256 _m)
func (_IFile *IFileFilterer) FilterWithdraw(opts *bind.FilterOpts, _a []common.Address) (*IFileWithdrawIterator, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _IFile.contract.FilterLogs(opts, "Withdraw", _aRule)
	if err != nil {
		return nil, err
	}
	return &IFileWithdrawIterator{contract: _IFile.contract, event: "Withdraw", logs: logs, sub: sub}, nil
}

// WatchWithdraw is a free log subscription operation binding the contract event 0x884edad9ce6fa2440d8a54cc123490eb96d2768479d49ff9c7366125a9424364.
//
// Solidity: event Withdraw(address indexed _a, uint256 _m)
func (_IFile *IFileFilterer) WatchWithdraw(opts *bind.WatchOpts, sink chan<- *IFileWithdraw, _a []common.Address) (event.Subscription, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _IFile.contract.WatchLogs(opts, "Withdraw", _aRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IFileWithdraw)
				if err := _IFile.contract.UnpackLog(event, "Withdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdraw is a log parse operation binding the contract event 0x884edad9ce6fa2440d8a54cc123490eb96d2768479d49ff9c7366125a9424364.
//
// Solidity: event Withdraw(address indexed _a, uint256 _m)
func (_IFile *IFileFilterer) ParseWithdraw(log types.Log) (*IFileWithdraw, error) {
	event := new(IFileWithdraw)
	if err := _IFile.contract.UnpackLog(event, "Withdraw", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// INodeABI is the input ABI used to generate the binding from.
const INodeABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_money\",\"type\":\"uint256\"}],\"name\":\"Pledge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_typ\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_money\",\"type\":\"uint256\"}],\"name\":\"Punish\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_money\",\"type\":\"uint256\"}],\"name\":\"Set\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_money\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"check\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"getMinPledge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"getPledgeValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_typ\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_money\",\"type\":\"uint256\"}],\"name\":\"punish\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// INodeFuncSigs maps the 4-byte function signature to its string representation.
var INodeFuncSigs = map[string]string{
	"61e728b1": "check(address,uint8)",
	"98c365d5": "getMinPledge(uint8)",
	"4339ceca": "getPledgeValue(address,uint8)",
	"06f0b4f1": "punish(address,uint8,address,uint256)",
}

// INode is an auto generated Go binding around an Ethereum contract.
type INode struct {
	INodeCaller     // Read-only binding to the contract
	INodeTransactor // Write-only binding to the contract
	INodeFilterer   // Log filterer for contract events
}

// INodeCaller is an auto generated read-only Go binding around an Ethereum contract.
type INodeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// INodeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type INodeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// INodeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type INodeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// INodeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type INodeSession struct {
	Contract     *INode            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// INodeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type INodeCallerSession struct {
	Contract *INodeCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// INodeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type INodeTransactorSession struct {
	Contract     *INodeTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// INodeRaw is an auto generated low-level Go binding around an Ethereum contract.
type INodeRaw struct {
	Contract *INode // Generic contract binding to access the raw methods on
}

// INodeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type INodeCallerRaw struct {
	Contract *INodeCaller // Generic read-only contract binding to access the raw methods on
}

// INodeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type INodeTransactorRaw struct {
	Contract *INodeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewINode creates a new instance of INode, bound to a specific deployed contract.
func NewINode(address common.Address, backend bind.ContractBackend) (*INode, error) {
	contract, err := bindINode(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &INode{INodeCaller: INodeCaller{contract: contract}, INodeTransactor: INodeTransactor{contract: contract}, INodeFilterer: INodeFilterer{contract: contract}}, nil
}

// NewINodeCaller creates a new read-only instance of INode, bound to a specific deployed contract.
func NewINodeCaller(address common.Address, caller bind.ContractCaller) (*INodeCaller, error) {
	contract, err := bindINode(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &INodeCaller{contract: contract}, nil
}

// NewINodeTransactor creates a new write-only instance of INode, bound to a specific deployed contract.
func NewINodeTransactor(address common.Address, transactor bind.ContractTransactor) (*INodeTransactor, error) {
	contract, err := bindINode(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &INodeTransactor{contract: contract}, nil
}

// NewINodeFilterer creates a new log filterer instance of INode, bound to a specific deployed contract.
func NewINodeFilterer(address common.Address, filterer bind.ContractFilterer) (*INodeFilterer, error) {
	contract, err := bindINode(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &INodeFilterer{contract: contract}, nil
}

// bindINode binds a generic wrapper to an already deployed contract.
func bindINode(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(INodeABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_INode *INodeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _INode.Contract.INodeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_INode *INodeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _INode.Contract.INodeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_INode *INodeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _INode.Contract.INodeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_INode *INodeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _INode.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_INode *INodeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _INode.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_INode *INodeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _INode.Contract.contract.Transact(opts, method, params...)
}

// Check is a free data retrieval call binding the contract method 0x61e728b1.
//
// Solidity: function check(address _a, uint8 _type) view returns()
func (_INode *INodeCaller) Check(opts *bind.CallOpts, _a common.Address, _type uint8) error {
	var out []interface{}
	err := _INode.contract.Call(opts, &out, "check", _a, _type)

	if err != nil {
		return err
	}

	return err

}

// Check is a free data retrieval call binding the contract method 0x61e728b1.
//
// Solidity: function check(address _a, uint8 _type) view returns()
func (_INode *INodeSession) Check(_a common.Address, _type uint8) error {
	return _INode.Contract.Check(&_INode.CallOpts, _a, _type)
}

// Check is a free data retrieval call binding the contract method 0x61e728b1.
//
// Solidity: function check(address _a, uint8 _type) view returns()
func (_INode *INodeCallerSession) Check(_a common.Address, _type uint8) error {
	return _INode.Contract.Check(&_INode.CallOpts, _a, _type)
}

// GetMinPledge is a free data retrieval call binding the contract method 0x98c365d5.
//
// Solidity: function getMinPledge(uint8 _type) view returns(uint256)
func (_INode *INodeCaller) GetMinPledge(opts *bind.CallOpts, _type uint8) (*big.Int, error) {
	var out []interface{}
	err := _INode.contract.Call(opts, &out, "getMinPledge", _type)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetMinPledge is a free data retrieval call binding the contract method 0x98c365d5.
//
// Solidity: function getMinPledge(uint8 _type) view returns(uint256)
func (_INode *INodeSession) GetMinPledge(_type uint8) (*big.Int, error) {
	return _INode.Contract.GetMinPledge(&_INode.CallOpts, _type)
}

// GetMinPledge is a free data retrieval call binding the contract method 0x98c365d5.
//
// Solidity: function getMinPledge(uint8 _type) view returns(uint256)
func (_INode *INodeCallerSession) GetMinPledge(_type uint8) (*big.Int, error) {
	return _INode.Contract.GetMinPledge(&_INode.CallOpts, _type)
}

// GetPledgeValue is a free data retrieval call binding the contract method 0x4339ceca.
//
// Solidity: function getPledgeValue(address _a, uint8 _type) view returns(uint256)
func (_INode *INodeCaller) GetPledgeValue(opts *bind.CallOpts, _a common.Address, _type uint8) (*big.Int, error) {
	var out []interface{}
	err := _INode.contract.Call(opts, &out, "getPledgeValue", _a, _type)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetPledgeValue is a free data retrieval call binding the contract method 0x4339ceca.
//
// Solidity: function getPledgeValue(address _a, uint8 _type) view returns(uint256)
func (_INode *INodeSession) GetPledgeValue(_a common.Address, _type uint8) (*big.Int, error) {
	return _INode.Contract.GetPledgeValue(&_INode.CallOpts, _a, _type)
}

// GetPledgeValue is a free data retrieval call binding the contract method 0x4339ceca.
//
// Solidity: function getPledgeValue(address _a, uint8 _type) view returns(uint256)
func (_INode *INodeCallerSession) GetPledgeValue(_a common.Address, _type uint8) (*big.Int, error) {
	return _INode.Contract.GetPledgeValue(&_INode.CallOpts, _a, _type)
}

// Punish is a paid mutator transaction binding the contract method 0x06f0b4f1.
//
// Solidity: function punish(address _a, uint8 _typ, address _to, uint256 _money) returns()
func (_INode *INodeTransactor) Punish(opts *bind.TransactOpts, _a common.Address, _typ uint8, _to common.Address, _money *big.Int) (*types.Transaction, error) {
	return _INode.contract.Transact(opts, "punish", _a, _typ, _to, _money)
}

// Punish is a paid mutator transaction binding the contract method 0x06f0b4f1.
//
// Solidity: function punish(address _a, uint8 _typ, address _to, uint256 _money) returns()
func (_INode *INodeSession) Punish(_a common.Address, _typ uint8, _to common.Address, _money *big.Int) (*types.Transaction, error) {
	return _INode.Contract.Punish(&_INode.TransactOpts, _a, _typ, _to, _money)
}

// Punish is a paid mutator transaction binding the contract method 0x06f0b4f1.
//
// Solidity: function punish(address _a, uint8 _typ, address _to, uint256 _money) returns()
func (_INode *INodeTransactorSession) Punish(_a common.Address, _typ uint8, _to common.Address, _money *big.Int) (*types.Transaction, error) {
	return _INode.Contract.Punish(&_INode.TransactOpts, _a, _typ, _to, _money)
}

// INodePledgeIterator is returned from FilterPledge and is used to iterate over the raw logs and unpacked data for Pledge events raised by the INode contract.
type INodePledgeIterator struct {
	Event *INodePledge // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *INodePledgeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(INodePledge)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(INodePledge)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *INodePledgeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *INodePledgeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// INodePledge represents a Pledge event raised by the INode contract.
type INodePledge struct {
	A     common.Address
	Type  uint8
	Money *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterPledge is a free log retrieval operation binding the contract event 0xedec38b4b62433445c926815411650aa7d417efa9da307f6aa99e69e6f4493ee.
//
// Solidity: event Pledge(address indexed _a, uint8 _type, uint256 _money)
func (_INode *INodeFilterer) FilterPledge(opts *bind.FilterOpts, _a []common.Address) (*INodePledgeIterator, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _INode.contract.FilterLogs(opts, "Pledge", _aRule)
	if err != nil {
		return nil, err
	}
	return &INodePledgeIterator{contract: _INode.contract, event: "Pledge", logs: logs, sub: sub}, nil
}

// WatchPledge is a free log subscription operation binding the contract event 0xedec38b4b62433445c926815411650aa7d417efa9da307f6aa99e69e6f4493ee.
//
// Solidity: event Pledge(address indexed _a, uint8 _type, uint256 _money)
func (_INode *INodeFilterer) WatchPledge(opts *bind.WatchOpts, sink chan<- *INodePledge, _a []common.Address) (event.Subscription, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _INode.contract.WatchLogs(opts, "Pledge", _aRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(INodePledge)
				if err := _INode.contract.UnpackLog(event, "Pledge", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePledge is a log parse operation binding the contract event 0xedec38b4b62433445c926815411650aa7d417efa9da307f6aa99e69e6f4493ee.
//
// Solidity: event Pledge(address indexed _a, uint8 _type, uint256 _money)
func (_INode *INodeFilterer) ParsePledge(log types.Log) (*INodePledge, error) {
	event := new(INodePledge)
	if err := _INode.contract.UnpackLog(event, "Pledge", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// INodePunishIterator is returned from FilterPunish and is used to iterate over the raw logs and unpacked data for Punish events raised by the INode contract.
type INodePunishIterator struct {
	Event *INodePunish // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *INodePunishIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(INodePunish)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(INodePunish)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *INodePunishIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *INodePunishIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// INodePunish represents a Punish event raised by the INode contract.
type INodePunish struct {
	A     common.Address
	Typ   uint8
	To    common.Address
	Money *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterPunish is a free log retrieval operation binding the contract event 0xc6ef96923e613455515c6723eff1723445b22427fe442e8bf742e9d29b4b3c32.
//
// Solidity: event Punish(address indexed _a, uint8 _typ, address indexed _to, uint256 _money)
func (_INode *INodeFilterer) FilterPunish(opts *bind.FilterOpts, _a []common.Address, _to []common.Address) (*INodePunishIterator, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _INode.contract.FilterLogs(opts, "Punish", _aRule, _toRule)
	if err != nil {
		return nil, err
	}
	return &INodePunishIterator{contract: _INode.contract, event: "Punish", logs: logs, sub: sub}, nil
}

// WatchPunish is a free log subscription operation binding the contract event 0xc6ef96923e613455515c6723eff1723445b22427fe442e8bf742e9d29b4b3c32.
//
// Solidity: event Punish(address indexed _a, uint8 _typ, address indexed _to, uint256 _money)
func (_INode *INodeFilterer) WatchPunish(opts *bind.WatchOpts, sink chan<- *INodePunish, _a []common.Address, _to []common.Address) (event.Subscription, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _INode.contract.WatchLogs(opts, "Punish", _aRule, _toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(INodePunish)
				if err := _INode.contract.UnpackLog(event, "Punish", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePunish is a log parse operation binding the contract event 0xc6ef96923e613455515c6723eff1723445b22427fe442e8bf742e9d29b4b3c32.
//
// Solidity: event Punish(address indexed _a, uint8 _typ, address indexed _to, uint256 _money)
func (_INode *INodeFilterer) ParsePunish(log types.Log) (*INodePunish, error) {
	event := new(INodePunish)
	if err := _INode.contract.UnpackLog(event, "Punish", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// INodeSetIterator is returned from FilterSet and is used to iterate over the raw logs and unpacked data for Set events raised by the INode contract.
type INodeSetIterator struct {
	Event *INodeSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *INodeSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(INodeSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(INodeSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *INodeSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *INodeSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// INodeSet represents a Set event raised by the INode contract.
type INodeSet struct {
	Type  uint8
	Money *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterSet is a free log retrieval operation binding the contract event 0xc4b70ab905e9fd7aab427fb9e73cae1480cfdc41c22053b20745349a7ef67881.
//
// Solidity: event Set(uint8 _type, uint256 _money)
func (_INode *INodeFilterer) FilterSet(opts *bind.FilterOpts) (*INodeSetIterator, error) {

	logs, sub, err := _INode.contract.FilterLogs(opts, "Set")
	if err != nil {
		return nil, err
	}
	return &INodeSetIterator{contract: _INode.contract, event: "Set", logs: logs, sub: sub}, nil
}

// WatchSet is a free log subscription operation binding the contract event 0xc4b70ab905e9fd7aab427fb9e73cae1480cfdc41c22053b20745349a7ef67881.
//
// Solidity: event Set(uint8 _type, uint256 _money)
func (_INode *INodeFilterer) WatchSet(opts *bind.WatchOpts, sink chan<- *INodeSet) (event.Subscription, error) {

	logs, sub, err := _INode.contract.WatchLogs(opts, "Set")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(INodeSet)
				if err := _INode.contract.UnpackLog(event, "Set", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSet is a log parse operation binding the contract event 0xc4b70ab905e9fd7aab427fb9e73cae1480cfdc41c22053b20745349a7ef67881.
//
// Solidity: event Set(uint8 _type, uint256 _money)
func (_INode *INodeFilterer) ParseSet(log types.Log) (*INodeSet, error) {
	event := new(INodeSet)
	if err := _INode.contract.UnpackLog(event, "Set", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// INodeWithdrawIterator is returned from FilterWithdraw and is used to iterate over the raw logs and unpacked data for Withdraw events raised by the INode contract.
type INodeWithdrawIterator struct {
	Event *INodeWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *INodeWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(INodeWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(INodeWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *INodeWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *INodeWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// INodeWithdraw represents a Withdraw event raised by the INode contract.
type INodeWithdraw struct {
	A     common.Address
	Type  uint8
	Money *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterWithdraw is a free log retrieval operation binding the contract event 0xe3054ec6f352b09a86839beeeceb27ed4684f9164eb61f4a5d6d159ee8789d74.
//
// Solidity: event Withdraw(address indexed _a, uint8 _type, uint256 _money)
func (_INode *INodeFilterer) FilterWithdraw(opts *bind.FilterOpts, _a []common.Address) (*INodeWithdrawIterator, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _INode.contract.FilterLogs(opts, "Withdraw", _aRule)
	if err != nil {
		return nil, err
	}
	return &INodeWithdrawIterator{contract: _INode.contract, event: "Withdraw", logs: logs, sub: sub}, nil
}

// WatchWithdraw is a free log subscription operation binding the contract event 0xe3054ec6f352b09a86839beeeceb27ed4684f9164eb61f4a5d6d159ee8789d74.
//
// Solidity: event Withdraw(address indexed _a, uint8 _type, uint256 _money)
func (_INode *INodeFilterer) WatchWithdraw(opts *bind.WatchOpts, sink chan<- *INodeWithdraw, _a []common.Address) (event.Subscription, error) {

	var _aRule []interface{}
	for _, _aItem := range _a {
		_aRule = append(_aRule, _aItem)
	}

	logs, sub, err := _INode.contract.WatchLogs(opts, "Withdraw", _aRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(INodeWithdraw)
				if err := _INode.contract.UnpackLog(event, "Withdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdraw is a log parse operation binding the contract event 0xe3054ec6f352b09a86839beeeceb27ed4684f9164eb61f4a5d6d159ee8789d74.
//
// Solidity: event Withdraw(address indexed _a, uint8 _type, uint256 _money)
func (_INode *INodeFilterer) ParseWithdraw(log types.Log) (*INodeWithdraw, error) {
	event := new(INodeWithdraw)
	if err := _INode.contract.UnpackLog(event, "Withdraw", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OwnableABI is the input ABI used to generate the binding from.
const OwnableABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// OwnableFuncSigs maps the 4-byte function signature to its string representation.
var OwnableFuncSigs = map[string]string{
	"8da5cb5b": "owner()",
	"715018a6": "renounceOwnership()",
	"f2fde38b": "transferOwnership(address)",
}

// Ownable is an auto generated Go binding around an Ethereum contract.
type Ownable struct {
	OwnableCaller     // Read-only binding to the contract
	OwnableTransactor // Write-only binding to the contract
	OwnableFilterer   // Log filterer for contract events
}

// OwnableCaller is an auto generated read-only Go binding around an Ethereum contract.
type OwnableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type OwnableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type OwnableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type OwnableSession struct {
	Contract     *Ownable          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OwnableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type OwnableCallerSession struct {
	Contract *OwnableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// OwnableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type OwnableTransactorSession struct {
	Contract     *OwnableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// OwnableRaw is an auto generated low-level Go binding around an Ethereum contract.
type OwnableRaw struct {
	Contract *Ownable // Generic contract binding to access the raw methods on
}

// OwnableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type OwnableCallerRaw struct {
	Contract *OwnableCaller // Generic read-only contract binding to access the raw methods on
}

// OwnableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type OwnableTransactorRaw struct {
	Contract *OwnableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewOwnable creates a new instance of Ownable, bound to a specific deployed contract.
func NewOwnable(address common.Address, backend bind.ContractBackend) (*Ownable, error) {
	contract, err := bindOwnable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Ownable{OwnableCaller: OwnableCaller{contract: contract}, OwnableTransactor: OwnableTransactor{contract: contract}, OwnableFilterer: OwnableFilterer{contract: contract}}, nil
}

// NewOwnableCaller creates a new read-only instance of Ownable, bound to a specific deployed contract.
func NewOwnableCaller(address common.Address, caller bind.ContractCaller) (*OwnableCaller, error) {
	contract, err := bindOwnable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OwnableCaller{contract: contract}, nil
}

// NewOwnableTransactor creates a new write-only instance of Ownable, bound to a specific deployed contract.
func NewOwnableTransactor(address common.Address, transactor bind.ContractTransactor) (*OwnableTransactor, error) {
	contract, err := bindOwnable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OwnableTransactor{contract: contract}, nil
}

// NewOwnableFilterer creates a new log filterer instance of Ownable, bound to a specific deployed contract.
func NewOwnableFilterer(address common.Address, filterer bind.ContractFilterer) (*OwnableFilterer, error) {
	contract, err := bindOwnable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OwnableFilterer{contract: contract}, nil
}

// bindOwnable binds a generic wrapper to an already deployed contract.
func bindOwnable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(OwnableABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Ownable *OwnableRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Ownable.Contract.OwnableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Ownable *OwnableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.Contract.OwnableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Ownable *OwnableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Ownable.Contract.OwnableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Ownable *OwnableCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Ownable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Ownable *OwnableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Ownable *OwnableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Ownable.Contract.contract.Transact(opts, method, params...)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Ownable.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableSession) Owner() (common.Address, error) {
	return _Ownable.Contract.Owner(&_Ownable.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableCallerSession) Owner() (common.Address, error) {
	return _Ownable.Contract.Owner(&_Ownable.CallOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Ownable *OwnableTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Ownable *OwnableSession) RenounceOwnership() (*types.Transaction, error) {
	return _Ownable.Contract.RenounceOwnership(&_Ownable.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Ownable *OwnableTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _Ownable.Contract.RenounceOwnership(&_Ownable.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.Contract.TransferOwnership(&_Ownable.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.Contract.TransferOwnership(&_Ownable.TransactOpts, newOwner)
}

// OwnableOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the Ownable contract.
type OwnableOwnershipTransferredIterator struct {
	Event *OwnableOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OwnableOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OwnableOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OwnableOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OwnableOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OwnableOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OwnableOwnershipTransferred represents a OwnershipTransferred event raised by the Ownable contract.
type OwnableOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*OwnableOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Ownable.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &OwnableOwnershipTransferredIterator{contract: _Ownable.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *OwnableOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Ownable.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OwnableOwnershipTransferred)
				if err := _Ownable.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) ParseOwnershipTransferred(log types.Log) (*OwnableOwnershipTransferred, error) {
	event := new(OwnableOwnershipTransferred)
	if err := _Ownable.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RecoverABI is the input ABI used to generate the binding from.
const RecoverABI = "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"recover\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]"

// RecoverFuncSigs maps the 4-byte function signature to its string representation.
var RecoverFuncSigs = map[string]string{
	"19045a25": "recover(bytes32,bytes)",
}

// RecoverBin is the compiled bytecode used for deploying new contracts.
var RecoverBin = "0x61029c61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100355760003560e01c806319045a251461003a575b600080fd5b61004d610048366004610184565b610069565b6040516001600160a01b03909116815260200160405180910390f35b6000815160411461007c57506000610168565b60208201516040830151606084015160001a7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08211156100c25760009350505050610168565b601b8160ff1610156100dc576100d981601b61023f565b90505b8060ff16601b141580156100f457508060ff16601c14155b156101055760009350505050610168565b60408051600081526020810180835288905260ff831691810191909152606081018490526080810183905260019060a0016020604051602081039080840390855afa158015610158573d6000803e3d6000fd5b5050506020604051035193505050505b92915050565b634e487b7160e01b600052604160045260246000fd5b6000806040838503121561019757600080fd5b82359150602083013567ffffffffffffffff808211156101b657600080fd5b818501915085601f8301126101ca57600080fd5b8135818111156101dc576101dc61016e565b604051601f8201601f19908116603f011681019083821181831017156102045761020461016e565b8160405282815288602084870101111561021d57600080fd5b8260208601602083013760006020848301015280955050505050509250929050565b60ff818116838216019081111561016857634e487b7160e01b600052601160045260246000fdfea2646970667358221220ac3390e9a7a8af550dae33b1bdd0c97027acfaeb4f307354bebb063239993c4364736f6c63430008130033"

// DeployRecover deploys a new Ethereum contract, binding an instance of Recover to it.
func DeployRecover(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Recover, error) {
	parsed, err := abi.JSON(strings.NewReader(RecoverABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(RecoverBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Recover{RecoverCaller: RecoverCaller{contract: contract}, RecoverTransactor: RecoverTransactor{contract: contract}, RecoverFilterer: RecoverFilterer{contract: contract}}, nil
}

// Recover is an auto generated Go binding around an Ethereum contract.
type Recover struct {
	RecoverCaller     // Read-only binding to the contract
	RecoverTransactor // Write-only binding to the contract
	RecoverFilterer   // Log filterer for contract events
}

// RecoverCaller is an auto generated read-only Go binding around an Ethereum contract.
type RecoverCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RecoverTransactor is an auto generated write-only Go binding around an Ethereum contract.
type RecoverTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RecoverFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type RecoverFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RecoverSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type RecoverSession struct {
	Contract     *Recover          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// RecoverCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type RecoverCallerSession struct {
	Contract *RecoverCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// RecoverTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type RecoverTransactorSession struct {
	Contract     *RecoverTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// RecoverRaw is an auto generated low-level Go binding around an Ethereum contract.
type RecoverRaw struct {
	Contract *Recover // Generic contract binding to access the raw methods on
}

// RecoverCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type RecoverCallerRaw struct {
	Contract *RecoverCaller // Generic read-only contract binding to access the raw methods on
}

// RecoverTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type RecoverTransactorRaw struct {
	Contract *RecoverTransactor // Generic write-only contract binding to access the raw methods on
}

// NewRecover creates a new instance of Recover, bound to a specific deployed contract.
func NewRecover(address common.Address, backend bind.ContractBackend) (*Recover, error) {
	contract, err := bindRecover(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Recover{RecoverCaller: RecoverCaller{contract: contract}, RecoverTransactor: RecoverTransactor{contract: contract}, RecoverFilterer: RecoverFilterer{contract: contract}}, nil
}

// NewRecoverCaller creates a new read-only instance of Recover, bound to a specific deployed contract.
func NewRecoverCaller(address common.Address, caller bind.ContractCaller) (*RecoverCaller, error) {
	contract, err := bindRecover(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &RecoverCaller{contract: contract}, nil
}

// NewRecoverTransactor creates a new write-only instance of Recover, bound to a specific deployed contract.
func NewRecoverTransactor(address common.Address, transactor bind.ContractTransactor) (*RecoverTransactor, error) {
	contract, err := bindRecover(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &RecoverTransactor{contract: contract}, nil
}

// NewRecoverFilterer creates a new log filterer instance of Recover, bound to a specific deployed contract.
func NewRecoverFilterer(address common.Address, filterer bind.ContractFilterer) (*RecoverFilterer, error) {
	contract, err := bindRecover(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &RecoverFilterer{contract: contract}, nil
}

// bindRecover binds a generic wrapper to an already deployed contract.
func bindRecover(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(RecoverABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Recover *RecoverRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Recover.Contract.RecoverCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Recover *RecoverRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Recover.Contract.RecoverTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Recover *RecoverRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Recover.Contract.RecoverTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Recover *RecoverCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Recover.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Recover *RecoverTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Recover.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Recover *RecoverTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Recover.Contract.contract.Transact(opts, method, params...)
}

// Recover is a free data retrieval call binding the contract method 0x19045a25.
//
// Solidity: function recover(bytes32 hash, bytes signature) pure returns(address)
func (_Recover *RecoverCaller) Recover(opts *bind.CallOpts, hash [32]byte, signature []byte) (common.Address, error) {
	var out []interface{}
	err := _Recover.contract.Call(opts, &out, "recover", hash, signature)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Recover is a free data retrieval call binding the contract method 0x19045a25.
//
// Solidity: function recover(bytes32 hash, bytes signature) pure returns(address)
func (_Recover *RecoverSession) Recover(hash [32]byte, signature []byte) (common.Address, error) {
	return _Recover.Contract.Recover(&_Recover.CallOpts, hash, signature)
}

// Recover is a free data retrieval call binding the contract method 0x19045a25.
//
// Solidity: function recover(bytes32 hash, bytes signature) pure returns(address)
func (_Recover *RecoverCallerSession) Recover(hash [32]byte, signature []byte) (common.Address, error) {
	return _Recover.Contract.Recover(&_Recover.CallOpts, hash, signature)
}
